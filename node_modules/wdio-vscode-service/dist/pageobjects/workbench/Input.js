var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import clipboard from 'clipboardy';
import { Key } from 'webdriverio';
import { BasePage, PageDecorator, sleep } from '../utils.js';
import { Input as InputLocators, InputBox as InputBoxLocators, QuickOpenBox as QuickOpenBoxLocators } from '../../locators/1.73.0.js';
import { CMD_KEY } from '../../constants.js';
const HOME_KEY = process.platform === 'win32'
    ? 'a'
    : Key.Home;
/**
 * Abstract page object for input fields
 *
 * @category Workbench
 */
export class Input extends BasePage {
    /**
     * Get current text of the input field
     * @returns Promise resolving to text of the input field
     */
    async getText() {
        const input = await this.inputBox$.$(this.locators.input);
        return input.getAttribute('value');
    }
    /**
     * Set (by selecting all and typing) text in the input field
     * @param text text to set into the input field
     * @returns Promise resolving when the text is typed in
     */
    async setText(text) {
        const input = await this.inputBox$.$(this.locators.input);
        await this.clear();
        await sleep(200);
        if ((await this.getText())?.length > 0) {
            await input.click();
            await browser.action('key')
                .down(Key.End).down(Key.Shift).down(Key.Home)
                .up(Key.End).up(Key.Shift).up(Key.Home)
                .perform();
        }
        await input.addValue(text);
        // fallback to clipboard if the text gets malformed
        const currentText = await this.getText();
        if (currentText !== text) {
            await clipboard.write(text);
            if (currentText?.length) {
                const backSpaces = new Array(currentText.length).fill(Key.Backspace);
                const keyAction = browser.action('key');
                for (const key of backSpaces) {
                    keyAction.down(key).up(key);
                }
                await keyAction.perform();
            }
            await clipboard.write('');
        }
    }
    /**
     * Get the placeholder text for the input field
     * @returns Promise resolving to input placeholder
     */
    async getPlaceHolder() {
        return this.inputBox$.$(this.locators.input).getAttribute('placeholder');
    }
    /**
     * Confirm the input field by pressing Enter
     * @returns Promise resolving when the input is confirmed
     */
    async confirm() {
        await browser.action('key').down(Key.Enter).up(Key.Enter).perform();
    }
    /**
     * Cancel the input field by pressing Escape
     * @returns Promise resolving when the input is cancelled
     */
    async cancel() {
        await browser.action('key').down(Key.Escape).up(Key.Escape).perform();
    }
    /**
     * Clear the input field
     * @returns Promise resolving when the field is cleared
     */
    async clear() {
        const input = await this.inputBox$.$(this.locators.input);
        await input.click();
        // VS Code 1.40 breaks the default clear method, use select all + back space instead
        await browser.action('key')
            .down(Key.End).up(Key.End)
            .perform();
        await browser.action('key')
            .down(CMD_KEY).down(HOME_KEY)
            .up(CMD_KEY).up(HOME_KEY)
            .perform();
        await browser.action('key')
            .down(Key.Backspace)
            .up(Key.Backspace)
            .perform();
        if ((await input.getAttribute('value'))?.length > 0) {
            await browser.action('key')
                .down(Key.End).up(Key.End)
                .perform();
            await browser.action('key')
                .down(CMD_KEY).down(HOME_KEY)
                .up(CMD_KEY).up(HOME_KEY)
                .perform();
            await browser.action('key')
                .down(Key.Backspace).up(Key.Backspace)
                .perform();
        }
    }
    /**
     * Select (click) a quick pick option. Will scroll through the quick picks to find the item.
     * Search for the item can be done by its text, or index in the quick pick menu.
     * Note that scrolling does not affect the item's index, but it will
     * replace some items in the DOM (thus they become unreachable)
     *
     * @param indexOrText index (number) or text (string) of the item to search by
     * @returns Promise resolving when the given quick pick is selected
     */
    async selectQuickPick(indexOrText) {
        const pick = await this.findQuickPick(indexOrText);
        if (pick) {
            await pick.select();
        }
        else {
            await this.resetPosition();
        }
    }
    /**
     * Select/Deselect all quick picks using the 'select all' checkbox
     * If multiple selection is disabled on the input box, no action is performed
     *
     * @param state true to select all, false to deselect all
     * @returns Promise resolving when all quick picks have been toggled to desired state
     */
    async toggleAllQuickPicks(state) {
        const checkboxes = await this.quickPickSelectAll$$;
        if (checkboxes.length < 0) {
            return;
        }
        if (!await checkboxes[0].isSelected()) {
            await checkboxes[0].click();
        }
        if (state === false) {
            await checkboxes[0].click();
        }
    }
    /**
     * Scroll through the quick picks to find an item by the name or index
     * @param indexOrText index (number) or text (string) of the item to search by
     * @returns Promise resolvnig to QuickPickItem if found, to undefined otherwise
     */
    async findQuickPick(indexOrText) {
        const first = await this.quickPickPosition$$(1);
        if (first.length < 1) {
            await this.resetPosition();
        }
        let endReached = false;
        while (!endReached) {
            const picks = await this.getQuickPicks();
            for (const pick of picks) {
                const lastRow = await this.elem.$$(this.locatorMap.DefaultTreeSection.lastRow);
                if (lastRow.length > 0) {
                    endReached = true;
                }
                else if (await pick.elem.getAttribute('aria-posinset') === await pick.elem.getAttribute('aria-setsize')) {
                    endReached = true;
                }
                if (typeof indexOrText === 'string') {
                    const text = await pick.getLabel();
                    if (text.indexOf(indexOrText) > -1) {
                        return pick;
                    }
                }
                else if (indexOrText === pick.getIndex()) {
                    return pick;
                }
            }
            if (!endReached) {
                await browser.action('key').down(Key.PageDown).up(Key.PageDown).perform();
            }
        }
        return undefined;
    }
    /**
     * Retrieve the title of an input box if it has one
     * @returns Promise resolving to title if it exists, to undefined otherwise
     */
    async getTitle() {
        const titleBar = await this.titleBar$$;
        if (titleBar.length > 0 && await titleBar[0].isDisplayed()) {
            return (await titleBar[0].$(this.locators.title)).getText();
        }
        return undefined;
    }
    /**
     * Click on the back button if it exists
     * @returns Promise resolving to true if a button was clicked, to false otherwise
     */
    async back() {
        const titleBar = await this.titleBar$$;
        if (titleBar.length > 0 && await titleBar[0].isDisplayed()) {
            const backBtn = await titleBar[0].$$(this.locators.backButton);
            if (backBtn.length > 0 && await backBtn[0].isEnabled()) {
                await backBtn[0].click();
                return true;
            }
        }
        return false;
    }
    async resetPosition() {
        const text = await this.getText();
        await this.clear();
        await this.setText(text || '');
    }
}
/**
 * Page object representing a quick pick option in the input box
 *
 * @category Workbench
 */
let QuickPickItem = class QuickPickItem extends BasePage {
    constructor(locators, index, inputField) {
        const quickPickPositionFn = locators.Input.quickPickPosition;
        const quickPickIndexFn = locators.Input.quickPickIndex;
        const baseParam = inputField instanceof QuickOpenBox
            ? quickPickPositionFn(index)
            : quickPickIndexFn(index);
        super(locators, baseParam);
        /**
         * @private
         */
        this.locatorKey = 'Input';
        this.index = index;
        this.input = inputField;
    }
    /**
     * Get the label of the quick pick item
     */
    async getLabel() {
        return this.quickPickLabel$.getText();
    }
    /**
     * Get the description of the quick pick item
     */
    async getDescription() {
        try {
            return await this.quickPickDescription$.getText();
        }
        catch (err) {
            return undefined;
        }
    }
    /**
     * Get the index of the quick pick item
     */
    getIndex() {
        return this.index;
    }
    /**
     * Select (click) the quick pick item
     * @returns Promise resolving when the item has been clicked
     */
    async select() {
        await this.elem.click();
    }
};
QuickPickItem = __decorate([
    PageDecorator(InputLocators)
], QuickPickItem);
export { QuickPickItem };
/**
 * Plain input box variation of the input page object
 *
 * @category Workbench
 */
let InputBox = class InputBox extends Input {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = ['Input', 'InputBox'];
    }
    /**
     * Get the message below the input field
     */
    async getMessage() {
        return this.message$.getText();
    }
    async hasProgress() {
        const klass = await this.progress$.getAttribute('class');
        return klass.indexOf('done') < 0;
    }
    async getQuickPicks() {
        const picks = [];
        const elements = await this.quickList$
            .$(this.locators.rows)
            .$$(this.locators.row);
        for (const element of elements) {
            if (await element.isDisplayed()) {
                picks.push(await new QuickPickItem(this.locatorMap, parseInt(await element.getAttribute('data-index'), 10), this).wait());
            }
        }
        return picks;
    }
    /**
     * Find whether the input is showing an error
     * @returns Promise resolving to notification message
     */
    async hasError() {
        const klass = await this.inputBox$.getAttribute('class');
        return klass.indexOf('error') > -1;
    }
    /**
     * Check if the input field is masked (input type password)
     * @returns Promise resolving to notification message
     */
    async isPassword() {
        return (await this.input$.getAttribute('type')) === 'password';
    }
};
InputBox = __decorate([
    PageDecorator({ ...InputLocators, ...InputBoxLocators })
], InputBox);
export { InputBox };
/**
 * @deprecated as of VS Code 1.44.0, quick open box has been replaced with input box
 * The quick open box variation of the input
 *
 * @category Workbench
 */
let QuickOpenBox = class QuickOpenBox extends Input {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = ['Input', 'QuickOpenBox'];
    }
    async hasProgress() {
        const klass = await this.progress$
            .getAttribute('class');
        return klass.indexOf('done') < 0;
    }
    async getQuickPicks() {
        const picks = [];
        const tree = await browser.$(this.locators.quickList);
        await tree.waitForExist({ timeout: 1000 });
        const elements = await tree.$$(this.locators.row);
        for (const element of elements) {
            const index = parseInt(await element.getAttribute('aria-posinset'), 10);
            if (await element.isDisplayed()) {
                picks.push(await new QuickPickItem(this.locatorMap, index, this).wait());
            }
        }
        return picks;
    }
};
QuickOpenBox = __decorate([
    PageDecorator({ ...InputLocators, ...QuickOpenBoxLocators })
], QuickOpenBox);
export { QuickOpenBox };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5wdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvd29ya2JlbmNoL0lucHV0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sU0FBUyxNQUFNLFlBQVksQ0FBQTtBQUNsQyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sYUFBYSxDQUFBO0FBRWpDLE9BQU8sRUFDYSxRQUFRLEVBQUUsYUFBYSxFQUFvQixLQUFLLEVBQ25FLE1BQU0sYUFBYSxDQUFBO0FBQ3BCLE9BQU8sRUFDSCxLQUFLLElBQUksYUFBYSxFQUN0QixRQUFRLElBQUksZ0JBQWdCLEVBQzVCLFlBQVksSUFBSSxvQkFBb0IsRUFDdkMsTUFBTSwwQkFBMEIsQ0FBQTtBQUNqQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sb0JBQW9CLENBQUE7QUFFNUMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPO0lBQ3pDLENBQUMsQ0FBQyxHQUFHO0lBQ0wsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUE7QUFJZDs7OztHQUlHO0FBQ0gsTUFBTSxPQUFnQixLQUFNLFNBQVEsUUFBMEI7SUFDMUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLE9BQU87UUFDVCxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDekQsT0FBTyxLQUFLLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQ3RDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLE9BQU8sQ0FBRSxJQUFZO1FBQ3ZCLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUN6RCxNQUFNLElBQUksQ0FBQyxLQUFLLEVB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TSxJQUFJLEdBQUcsTUFBTSxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUE7UUFDckQsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUE7UUFDMUMsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUE7UUFDakQsS0FBSyxNQUFNLE9BQU8sSUFBSSxRQUFRLEVBQUUsQ0FBQztZQUM3QixNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsTUFBTSxPQUFPLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBO1lBQ3ZFLElBQUksTUFBTSxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQztnQkFDOUIsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUE7WUFDNUUsQ0FBQztRQUNMLENBQUM7UUFDRCxPQUFPLEtBQUssQ0FBQTtJQUNoQixDQUFDO0NBQ0osQ0FBQTtBQXpCWSxZQUFZO0lBRHhCLGFBQWEsQ0FBQyxFQUFFLEdBQUcsYUFBYSxFQUFFLEdBQUcsb0JBQW9CLEVBQUUsQ0FBQztHQUNoRCxZQUFZLENBeUJ4QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjbGlwYm9hcmQgZnJvbSAnY2xpcGJvYXJkeSdcbmltcG9ydCB7IEtleSB9IGZyb20gJ3dlYmRyaXZlcmlvJ1xuXG5pbXBvcnQge1xuICAgIElQYWdlRGVjb3JhdG9yLCBCYXNlUGFnZSwgUGFnZURlY29yYXRvciwgVlNDb2RlTG9jYXRvck1hcCwgc2xlZXBcbn0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQge1xuICAgIElucHV0IGFzIElucHV0TG9jYXRvcnMsXG4gICAgSW5wdXRCb3ggYXMgSW5wdXRCb3hMb2NhdG9ycyxcbiAgICBRdWlja09wZW5Cb3ggYXMgUXVpY2tPcGVuQm94TG9jYXRvcnNcbn0gZnJvbSAnLi4vLi4vbG9jYXRvcnMvMS43My4wLmpzJ1xuaW1wb3J0IHsgQ01EX0tFWSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcydcblxuY29uc3QgSE9NRV9LRVkgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgPyAnYSdcbiAgICA6IEtleS5Ib21lXG5cbnR5cGUgQWxsSW5wdXRMb2NhdG9ycyA9IHR5cGVvZiBJbnB1dExvY2F0b3JzICYgdHlwZW9mIElucHV0Qm94TG9jYXRvcnMgJiB0eXBlb2YgUXVpY2tPcGVuQm94TG9jYXRvcnNcbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXQgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjxBbGxJbnB1dExvY2F0b3JzPiB7fVxuLyoqXG4gKiBBYnN0cmFjdCBwYWdlIG9iamVjdCBmb3IgaW5wdXQgZmllbGRzXG4gKlxuICogQGNhdGVnb3J5IFdvcmtiZW5jaFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5wdXQgZXh0ZW5kcyBCYXNlUGFnZTxBbGxJbnB1dExvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiB0aGUgaW5wdXQgZmllbGRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0ZXh0IG9mIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIGFzeW5jIGdldFRleHQgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXdhaXQgdGhpcy5pbnB1dEJveCQuJCh0aGlzLmxvY2F0b3JzLmlucHV0KVxuICAgICAgICByZXR1cm4gaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IChieSBzZWxlY3RpbmcgYWxsIGFuZCB0eXBpbmcpIHRleHQgaW4gdGhlIGlucHV0IGZpZWxkXG4gICAgICogQHBhcmFtIHRleHQgdGV4dCB0byBzZXQgaW50byB0aGUgaW5wdXQgZmllbGRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSB0ZXh0IGlzIHR5cGVkIGluXG4gICAgICovXG4gICAgYXN5bmMgc2V0VGV4dCAodGV4dDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXdhaXQgdGhpcy5pbnB1dEJveCQuJCh0aGlzLmxvY2F0b3JzLmlucHV0KVxuICAgICAgICBhd2FpdCB0aGlzLmNsZWFyKClcbiAgICAgICAgYXdhaXQgc2xlZXAoMjAwKVxuICAgICAgICBpZiAoKGF3YWl0IHRoaXMuZ2V0VGV4dCgpKT8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgaW5wdXQuY2xpY2soKVxuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAgICAgLmRvd24oS2V5LkVuZCkuZG93bihLZXkuU2hpZnQpLmRvd24oS2V5LkhvbWUpXG4gICAgICAgICAgICAgICAgLnVwKEtleS5FbmQpLnVwKEtleS5TaGlmdCkudXAoS2V5LkhvbWUpXG4gICAgICAgICAgICAgICAgLnBlcmZvcm0oKVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGlucHV0LmFkZFZhbHVlKHRleHQpXG5cbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gY2xpcGJvYXJkIGlmIHRoZSB0ZXh0IGdldHMgbWFsZm9ybWVkXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0ID0gYXdhaXQgdGhpcy5nZXRUZXh0KClcbiAgICAgICAgaWYgKGN1cnJlbnRUZXh0ICE9PSB0ZXh0KSB7XG4gICAgICAgICAgICBhd2FpdCBjbGlwYm9hcmQud3JpdGUodGV4dClcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dD8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFja1NwYWNlczogc3RyaW5nW10gPSBuZXcgQXJyYXkoY3VycmVudFRleHQubGVuZ3RoKS5maWxsKEtleS5CYWNrc3BhY2UpXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5QWN0aW9uID0gYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgYmFja1NwYWNlcykge1xuICAgICAgICAgICAgICAgICAgICBrZXlBY3Rpb24uZG93bihrZXkpLnVwKGtleSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQga2V5QWN0aW9uLnBlcmZvcm0oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgY2xpcGJvYXJkLndyaXRlKCcnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwbGFjZWhvbGRlciB0ZXh0IGZvciB0aGUgaW5wdXQgZmllbGRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBpbnB1dCBwbGFjZWhvbGRlclxuICAgICAqL1xuICAgIGFzeW5jIGdldFBsYWNlSG9sZGVyICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dEJveCQuJCh0aGlzLmxvY2F0b3JzLmlucHV0KS5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maXJtIHRoZSBpbnB1dCBmaWVsZCBieSBwcmVzc2luZyBFbnRlclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGlucHV0IGlzIGNvbmZpcm1lZFxuICAgICAqL1xuICAgIGFzeW5jIGNvbmZpcm0gKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JykuZG93bihLZXkuRW50ZXIpLnVwKEtleS5FbnRlcikucGVyZm9ybSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoZSBpbnB1dCBmaWVsZCBieSBwcmVzc2luZyBFc2NhcGVcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBpbnB1dCBpcyBjYW5jZWxsZWRcbiAgICAgKi9cbiAgICBhc3luYyBjYW5jZWwgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JykuZG93bihLZXkuRXNjYXBlKS51cChLZXkuRXNjYXBlKS5wZXJmb3JtKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgaW5wdXQgZmllbGRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBmaWVsZCBpcyBjbGVhcmVkXG4gICAgICovXG4gICAgYXN5bmMgY2xlYXIgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGF3YWl0IHRoaXMuaW5wdXRCb3gkLiQodGhpcy5sb2NhdG9ycy5pbnB1dClcbiAgICAgICAgYXdhaXQgaW5wdXQuY2xpY2soKVxuICAgICAgICAvLyBWUyBDb2RlIDEuNDAgYnJlYWtzIHRoZSBkZWZhdWx0IGNsZWFyIG1ldGhvZCwgdXNlIHNlbGVjdCBhbGwgKyBiYWNrIHNwYWNlIGluc3RlYWRcbiAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAuZG93bihLZXkuRW5kKS51cChLZXkuRW5kKVxuICAgICAgICAgICAgLnBlcmZvcm0oKVxuICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JylcbiAgICAgICAgICAgIC5kb3duKENNRF9LRVkpLmRvd24oSE9NRV9LRVkpXG4gICAgICAgICAgICAudXAoQ01EX0tFWSkudXAoSE9NRV9LRVkpXG4gICAgICAgICAgICAucGVyZm9ybSgpXG4gICAgICAgIGF3YWl0IGJyb3dzZXIuYWN0aW9uKCdrZXknKVxuICAgICAgICAgICAgLmRvd24oS2V5LkJhY2tzcGFjZSlcbiAgICAgICAgICAgIC51cChLZXkuQmFja3NwYWNlKVxuICAgICAgICAgICAgLnBlcmZvcm0oKVxuICAgICAgICBpZiAoKGF3YWl0IGlucHV0LmdldEF0dHJpYnV0ZSgndmFsdWUnKSk/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IGJyb3dzZXIuYWN0aW9uKCdrZXknKVxuICAgICAgICAgICAgICAgIC5kb3duKEtleS5FbmQpLnVwKEtleS5FbmQpXG4gICAgICAgICAgICAgICAgLnBlcmZvcm0oKVxuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAgICAgLmRvd24oQ01EX0tFWSkuZG93bihIT01FX0tFWSlcbiAgICAgICAgICAgICAgICAudXAoQ01EX0tFWSkudXAoSE9NRV9LRVkpXG4gICAgICAgICAgICAgICAgLnBlcmZvcm0oKVxuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAgICAgLmRvd24oS2V5LkJhY2tzcGFjZSkudXAoS2V5LkJhY2tzcGFjZSlcbiAgICAgICAgICAgICAgICAucGVyZm9ybSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgKGNsaWNrKSBhIHF1aWNrIHBpY2sgb3B0aW9uLiBXaWxsIHNjcm9sbCB0aHJvdWdoIHRoZSBxdWljayBwaWNrcyB0byBmaW5kIHRoZSBpdGVtLlxuICAgICAqIFNlYXJjaCBmb3IgdGhlIGl0ZW0gY2FuIGJlIGRvbmUgYnkgaXRzIHRleHQsIG9yIGluZGV4IGluIHRoZSBxdWljayBwaWNrIG1lbnUuXG4gICAgICogTm90ZSB0aGF0IHNjcm9sbGluZyBkb2VzIG5vdCBhZmZlY3QgdGhlIGl0ZW0ncyBpbmRleCwgYnV0IGl0IHdpbGxcbiAgICAgKiByZXBsYWNlIHNvbWUgaXRlbXMgaW4gdGhlIERPTSAodGh1cyB0aGV5IGJlY29tZSB1bnJlYWNoYWJsZSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleE9yVGV4dCBpbmRleCAobnVtYmVyKSBvciB0ZXh0IChzdHJpbmcpIG9mIHRoZSBpdGVtIHRvIHNlYXJjaCBieVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGdpdmVuIHF1aWNrIHBpY2sgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBzZWxlY3RRdWlja1BpY2sgKGluZGV4T3JUZXh0OiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgcGljayA9IGF3YWl0IHRoaXMuZmluZFF1aWNrUGljayhpbmRleE9yVGV4dClcbiAgICAgICAgaWYgKHBpY2spIHtcbiAgICAgICAgICAgIGF3YWl0IHBpY2suc2VsZWN0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVzZXRQb3NpdGlvbigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QvRGVzZWxlY3QgYWxsIHF1aWNrIHBpY2tzIHVzaW5nIHRoZSAnc2VsZWN0IGFsbCcgY2hlY2tib3hcbiAgICAgKiBJZiBtdWx0aXBsZSBzZWxlY3Rpb24gaXMgZGlzYWJsZWQgb24gdGhlIGlucHV0IGJveCwgbm8gYWN0aW9uIGlzIHBlcmZvcm1lZFxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIHRydWUgdG8gc2VsZWN0IGFsbCwgZmFsc2UgdG8gZGVzZWxlY3QgYWxsXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhbGwgcXVpY2sgcGlja3MgaGF2ZSBiZWVuIHRvZ2dsZWQgdG8gZGVzaXJlZCBzdGF0ZVxuICAgICAqL1xuICAgIGFzeW5jIHRvZ2dsZUFsbFF1aWNrUGlja3MgKHN0YXRlOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSBhd2FpdCB0aGlzLnF1aWNrUGlja1NlbGVjdEFsbCQkXG4gICAgICAgIGlmIChjaGVja2JveGVzLmxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICghYXdhaXQgY2hlY2tib3hlc1swXS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrYm94ZXNbMF0uY2xpY2soKVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrYm94ZXNbMF0uY2xpY2soKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRocm91Z2ggdGhlIHF1aWNrIHBpY2tzIHRvIGZpbmQgYW4gaXRlbSBieSB0aGUgbmFtZSBvciBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleE9yVGV4dCBpbmRleCAobnVtYmVyKSBvciB0ZXh0IChzdHJpbmcpIG9mIHRoZSBpdGVtIHRvIHNlYXJjaCBieVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2bmlnIHRvIFF1aWNrUGlja0l0ZW0gaWYgZm91bmQsIHRvIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBmaW5kUXVpY2tQaWNrIChpbmRleE9yVGV4dDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxRdWlja1BpY2tJdGVtIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gYXdhaXQgdGhpcy5xdWlja1BpY2tQb3NpdGlvbiQkKDEpXG4gICAgICAgIGlmIChmaXJzdC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc2V0UG9zaXRpb24oKVxuICAgICAgICB9XG4gICAgICAgIGxldCBlbmRSZWFjaGVkID0gZmFsc2VcblxuICAgICAgICB3aGlsZSAoIWVuZFJlYWNoZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBpY2tzID0gYXdhaXQgdGhpcy5nZXRRdWlja1BpY2tzKClcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGljayBvZiBwaWNrcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RSb3cgPSBhd2FpdCB0aGlzLmVsZW0uJCQodGhpcy5sb2NhdG9yTWFwLkRlZmF1bHRUcmVlU2VjdGlvbi5sYXN0Um93IGFzIHN0cmluZylcbiAgICAgICAgICAgICAgICBpZiAobGFzdFJvdy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZFJlYWNoZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGljay5lbGVtLmdldEF0dHJpYnV0ZSgnYXJpYS1wb3NpbnNldCcpID09PSBhd2FpdCBwaWNrLmVsZW0uZ2V0QXR0cmlidXRlKCdhcmlhLXNldHNpemUnKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBlbmRSZWFjaGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4T3JUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcGljay5nZXRMYWJlbCgpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0LmluZGV4T2YoaW5kZXhPclRleHQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwaWNrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4T3JUZXh0ID09PSBwaWNrLmdldEluZGV4KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVuZFJlYWNoZWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JykuZG93bihLZXkuUGFnZURvd24pLnVwKEtleS5QYWdlRG93bikucGVyZm9ybSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSB0aXRsZSBvZiBhbiBpbnB1dCBib3ggaWYgaXQgaGFzIG9uZVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRpdGxlIGlmIGl0IGV4aXN0cywgdG8gdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFzeW5jIGdldFRpdGxlICgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgICAgICBjb25zdCB0aXRsZUJhciA9IGF3YWl0IHRoaXMudGl0bGVCYXIkJFxuICAgICAgICBpZiAodGl0bGVCYXIubGVuZ3RoID4gMCAmJiBhd2FpdCB0aXRsZUJhclswXS5pc0Rpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IHRpdGxlQmFyWzBdLiQodGhpcy5sb2NhdG9ycy50aXRsZSkpLmdldFRleHQoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGljayBvbiB0aGUgYmFjayBidXR0b24gaWYgaXQgZXhpc3RzXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiBhIGJ1dHRvbiB3YXMgY2xpY2tlZCwgdG8gZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYXN5bmMgYmFjayAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IHRpdGxlQmFyID0gYXdhaXQgdGhpcy50aXRsZUJhciQkXG4gICAgICAgIGlmICh0aXRsZUJhci5sZW5ndGggPiAwICYmIGF3YWl0IHRpdGxlQmFyWzBdLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhY2tCdG4gPSBhd2FpdCB0aXRsZUJhclswXS4kJCh0aGlzLmxvY2F0b3JzLmJhY2tCdXR0b24pXG4gICAgICAgICAgICBpZiAoYmFja0J0bi5sZW5ndGggPiAwICYmIGF3YWl0IGJhY2tCdG5bMF0uaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBiYWNrQnRuWzBdLmNsaWNrKClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgd2hldGhlciB0aGUgaW5wdXQgYm94IGhhcyBhbiBhY3RpdmUgcHJvZ3Jlc3MgYmFyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZS9mYWxzZVxuICAgICAqL1xuICAgIGFic3RyYWN0IGhhc1Byb2dyZXNzICgpOiBQcm9taXNlPGJvb2xlYW4+XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcXVpY2sgcGljayBpdGVtcyBjdXJyZW50bHkgYXZhaWxhYmxlIGluIHRoZSBET01cbiAgICAgKiAodmlzaWJsZSBpbiB0aGUgcXVpY2sgcGljayBtZW51KVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIFF1aWNrUGlja0l0ZW0gb2JqZWN0c1xuICAgICAqL1xuICAgIGFic3RyYWN0IGdldFF1aWNrUGlja3MgKCk6IFByb21pc2U8UXVpY2tQaWNrSXRlbVtdPlxuXG4gICAgcHJpdmF0ZSBhc3luYyByZXNldFBvc2l0aW9uICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHRoaXMuZ2V0VGV4dCgpXG4gICAgICAgIGF3YWl0IHRoaXMuY2xlYXIoKVxuICAgICAgICBhd2FpdCB0aGlzLnNldFRleHQodGV4dCB8fCAnJylcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVpY2tQaWNrSXRlbSBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBJbnB1dExvY2F0b3JzPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCByZXByZXNlbnRpbmcgYSBxdWljayBwaWNrIG9wdGlvbiBpbiB0aGUgaW5wdXQgYm94XG4gKlxuICogQGNhdGVnb3J5IFdvcmtiZW5jaFxuICovXG5AUGFnZURlY29yYXRvcihJbnB1dExvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFF1aWNrUGlja0l0ZW0gZXh0ZW5kcyBCYXNlUGFnZTx0eXBlb2YgSW5wdXRMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnSW5wdXQnIGFzIGNvbnN0XG4gICAgcHJpdmF0ZSBpbmRleDogbnVtYmVyXG4gICAgcHVibGljIGlucHV0OiBJbnB1dFxuXG4gICAgY29uc3RydWN0b3IgKGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLCBpbmRleDogbnVtYmVyLCBpbnB1dEZpZWxkOiBJbnB1dCkge1xuICAgICAgICBjb25zdCBxdWlja1BpY2tQb3NpdGlvbkZuID0gbG9jYXRvcnMuSW5wdXQucXVpY2tQaWNrUG9zaXRpb24gYXMgRnVuY3Rpb25cbiAgICAgICAgY29uc3QgcXVpY2tQaWNrSW5kZXhGbiA9IGxvY2F0b3JzLklucHV0LnF1aWNrUGlja0luZGV4IGFzIEZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IGJhc2VQYXJhbSA9IGlucHV0RmllbGQgaW5zdGFuY2VvZiBRdWlja09wZW5Cb3hcbiAgICAgICAgICAgID8gcXVpY2tQaWNrUG9zaXRpb25GbihpbmRleCkgYXMgc3RyaW5nXG4gICAgICAgICAgICA6IHF1aWNrUGlja0luZGV4Rm4oaW5kZXgpIGFzIHN0cmluZ1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgYmFzZVBhcmFtKVxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXhcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0RmllbGRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxhYmVsIG9mIHRoZSBxdWljayBwaWNrIGl0ZW1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRMYWJlbCAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVpY2tQaWNrTGFiZWwkLmdldFRleHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHF1aWNrIHBpY2sgaXRlbVxuICAgICAqL1xuICAgIGFzeW5jIGdldERlc2NyaXB0aW9uICgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucXVpY2tQaWNrRGVzY3JpcHRpb24kLmdldFRleHQoKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIHF1aWNrIHBpY2sgaXRlbVxuICAgICAqL1xuICAgIGdldEluZGV4ICgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCAoY2xpY2spIHRoZSBxdWljayBwaWNrIGl0ZW1cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBpdGVtIGhhcyBiZWVuIGNsaWNrZWRcbiAgICAgKi9cbiAgICBhc3luYyBzZWxlY3QgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLmVsZW0uY2xpY2soKVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dEJveCBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBJbnB1dEJveExvY2F0b3JzPiB7fVxuLyoqXG4gKiBQbGFpbiBpbnB1dCBib3ggdmFyaWF0aW9uIG9mIHRoZSBpbnB1dCBwYWdlIG9iamVjdFxuICpcbiAqIEBjYXRlZ29yeSBXb3JrYmVuY2hcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoeyAuLi5JbnB1dExvY2F0b3JzLCAuLi5JbnB1dEJveExvY2F0b3JzIH0pXG5leHBvcnQgY2xhc3MgSW5wdXRCb3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9IFsnSW5wdXQnIGFzIGNvbnN0LCAnSW5wdXRCb3gnIGFzIGNvbnN0XVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtZXNzYWdlIGJlbG93IHRoZSBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIGFzeW5jIGdldE1lc3NhZ2UgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UkLmdldFRleHQoKVxuICAgIH1cblxuICAgIGFzeW5jIGhhc1Byb2dyZXNzICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3Qga2xhc3MgPSBhd2FpdCB0aGlzLnByb2dyZXNzJC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcbiAgICAgICAgcmV0dXJuIGtsYXNzLmluZGV4T2YoJ2RvbmUnKSA8IDBcbiAgICB9XG5cbiAgICBhc3luYyBnZXRRdWlja1BpY2tzICgpOiBQcm9taXNlPFF1aWNrUGlja0l0ZW1bXT4ge1xuICAgICAgICBjb25zdCBwaWNrczogUXVpY2tQaWNrSXRlbVtdID0gW11cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBhd2FpdCB0aGlzLnF1aWNrTGlzdCRcbiAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvcnMucm93cylcbiAgICAgICAgICAgIC4kJCh0aGlzLmxvY2F0b3JzLnJvdylcblxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChhd2FpdCBlbGVtZW50LmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICBwaWNrcy5wdXNoKGF3YWl0IG5ldyBRdWlja1BpY2tJdGVtKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0b3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGF3YWl0IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICkud2FpdCgpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgd2hldGhlciB0aGUgaW5wdXQgaXMgc2hvd2luZyBhbiBlcnJvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGlmaWNhdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgaGFzRXJyb3IgKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBrbGFzcyA9IGF3YWl0IHRoaXMuaW5wdXRCb3gkLmdldEF0dHJpYnV0ZSgnY2xhc3MnKVxuICAgICAgICByZXR1cm4ga2xhc3MuaW5kZXhPZignZXJyb3InKSA+IC0xXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGlucHV0IGZpZWxkIGlzIG1hc2tlZCAoaW5wdXQgdHlwZSBwYXNzd29yZClcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBub3RpZmljYXRpb24gbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIGlzUGFzc3dvcmQgKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuaW5wdXQkLmdldEF0dHJpYnV0ZSgndHlwZScpKSA9PT0gJ3Bhc3N3b3JkJ1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWlja09wZW5Cb3ggZXh0ZW5kcyBJUGFnZURlY29yYXRvcjxBbGxJbnB1dExvY2F0b3JzPiB7fVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBhcyBvZiBWUyBDb2RlIDEuNDQuMCwgcXVpY2sgb3BlbiBib3ggaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBpbnB1dCBib3hcbiAqIFRoZSBxdWljayBvcGVuIGJveCB2YXJpYXRpb24gb2YgdGhlIGlucHV0XG4gKlxuICogQGNhdGVnb3J5IFdvcmtiZW5jaFxuICovXG5AUGFnZURlY29yYXRvcih7IC4uLklucHV0TG9jYXRvcnMsIC4uLlF1aWNrT3BlbkJveExvY2F0b3JzIH0pXG5leHBvcnQgY2xhc3MgUXVpY2tPcGVuQm94IGV4dGVuZHMgSW5wdXQge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSBbJ0lucHV0JyBhcyBjb25zdCwgJ1F1aWNrT3BlbkJveCcgYXMgY29uc3RdXG5cbiAgICBhc3luYyBoYXNQcm9ncmVzcyAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGtsYXNzID0gYXdhaXQgdGhpcy5wcm9ncmVzcyRcbiAgICAgICAgICAgIC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcbiAgICAgICAgcmV0dXJuIGtsYXNzLmluZGV4T2YoJ2RvbmUnKSA8IDBcbiAgICB9XG5cbiAgICBhc3luYyBnZXRRdWlja1BpY2tzICgpOiBQcm9taXNlPFF1aWNrUGlja0l0ZW1bXT4ge1xuICAgICAgICBjb25zdCBwaWNrczogUXVpY2tQaWNrSXRlbVtdID0gW11cbiAgICAgICAgY29uc3QgdHJlZSA9IGF3YWl0IGJyb3dzZXIuJCh0aGlzLmxvY2F0b3JzLnF1aWNrTGlzdClcbiAgICAgICAgYXdhaXQgdHJlZS53YWl0Rm9yRXhpc3QoeyB0aW1lb3V0OiAxMDAwIH0pXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gYXdhaXQgdHJlZS4kJCh0aGlzLmxvY2F0b3JzLnJvdylcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KGF3YWl0IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLXBvc2luc2V0JyksIDEwKVxuICAgICAgICAgICAgaWYgKGF3YWl0IGVsZW1lbnQuaXNEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgICAgIHBpY2tzLnB1c2goYXdhaXQgbmV3IFF1aWNrUGlja0l0ZW0odGhpcy5sb2NhdG9yTWFwLCBpbmRleCwgdGhpcykud2FpdCgpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrc1xuICAgIH1cbn1cbiJdfQ==