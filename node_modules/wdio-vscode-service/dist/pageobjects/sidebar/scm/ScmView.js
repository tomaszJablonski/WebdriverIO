var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Key } from 'webdriverio';
import { SideBarView } from '../SideBarView.js';
import { ContextMenu } from '../../index.js';
import { ElementWithContextMenu, PageDecorator, BasePage } from '../../utils.js';
import { ScmView as ScmViewLocators } from '../../../locators/1.73.0.js';
import { CMD_KEY } from '../../../constants.js';
/**
 * Page object representing the Source Control view
 *
 * @category Sidebar
 */
let ScmView = class ScmView extends SideBarView {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get SCM provider (repository) by title
     * @param title name of the repository
     * @returns promise resolving to ScmProvider object
     */
    async getProvider(title) {
        const providers = await this.getProviders();
        if (!title || providers.length === 1) {
            return providers[0];
        }
        const names = await Promise.all(providers.map(async (item) => item.getTitle()));
        const index = names.findIndex((name) => name === title);
        return index > -1 ? providers[index] : undefined;
    }
    /**
     * Get all SCM providers
     * @returns promise resolving to ScmProvider array
     */
    async getProviders() {
        const headers = await this.providerHeader$$;
        const sections = await Promise.all(headers.map(async (header) => header.$(this.locators.providerRelative)));
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return Promise.all(sections.map((section) => new ScmProvider(this.locatorMap, section, this)));
    }
    /**
     * Initialize repository in the current folder if no SCM provider is found
     * @returns true if the action was completed succesfully, false if a provider already exists
     */
    async initializeRepository() {
        const buttons = await this.initButton$$;
        if (buttons.length > 0) {
            await buttons[0].click();
            return true;
        }
        return false;
    }
};
ScmView = __decorate([
    PageDecorator(ScmViewLocators)
], ScmView);
export { ScmView };
/**
 * Page object representing a repository in the source control view
 * Maps roughly to a view section of the source control view
 *
 * @category Sidebar
 */
let ScmProvider = class ScmProvider extends BasePage {
    constructor(locators, element, view) {
        super(locators, element, view.elem);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get title of the scm provider
     */
    async getTitle() {
        return this.providerTitle$.getAttribute('innerHTML');
    }
    /**
     * Get type of the scm provider (e.g. Git)
     */
    async getType() {
        return this.providerType$.getAttribute('innerHTML');
    }
    /**
     * Find an action button for the SCM provider by title and click it. (e.g 'Commit')
     * @param title Title of the action button to click
     * @returns true if the given action could be performed, false if the button doesn't exist
     */
    async takeAction(title) {
        const header = await this.providerHeader$;
        let actions = [];
        if ((await header.getAttribute('class')).indexOf('hidden') > -1) {
            actions = (await this.view.getTitlePart().getActions()).map((action) => action.elem);
        }
        else {
            await this.elem.moveTo();
            actions = await header.$$(this.locators.action);
        }
        const names = await Promise.all(actions.map((action) => action.getAttribute('title')));
        const index = names.findIndex((item) => item === title);
        if (index > -1) {
            await actions[index].click();
            return true;
        }
        return false;
    }
    /**
     * Open a context menu using the 'More Actions...' button
     * @returns Promise resolving to a ContextMenu object
     */
    async openMoreActions() {
        const header = await this.providerHeader$;
        if ((await header.getAttribute('class')).indexOf('hidden') > -1) {
            return new MoreAction(this.locatorMap, this.view).openContextMenu();
        }
        await this.elem.moveTo();
        return new MoreAction(this.locatorMap, this).openContextMenu();
    }
    /**
     * Fill in the message field and send ctrl/cmd + enter to commit the changes
     * @param message the commit message to use
     * @returns promise resolving once the keypresses are sent
     */
    async commitChanges(message) {
        const input = await this.inputField$;
        await input.clearValue();
        await input.addValue(message);
        await browser.action('key')
            .down(CMD_KEY).down(Key.Enter)
            .up(CMD_KEY).up(Key.Enter)
            .perform();
    }
    /**
     * Get page objects for all tree items representing individual changes
     * @param staged when true, finds staged changes otherwise finds unstaged changes
     * @returns promise resolving to ScmChange object array
     */
    async getChanges(staged = false) {
        const changes = await this.getChangeCount(staged);
        const label = staged ? 'STAGED CHANGES' : 'CHANGES';
        let elements = [];
        if (changes > 0) {
            let i = -1;
            elements = await this.changeItem$$;
            for (const [index, item] of elements.entries()) {
                const name = await item.$(this.locators.changeName);
                if (await name.getText() === label) {
                    i = index + 1;
                    break;
                }
            }
            if (i < 0) {
                return [];
            }
            elements = elements.slice(i, i + changes);
        }
        return Promise.all(elements.map((element) => (new ScmChange(this.locatorMap, element, this).wait())));
    }
    /**
     * Get the number of changes for a given section
     * @param staged when true, counts the staged changes, unstaged otherwise
     * @returns promise resolving to number of changes in the given subsection
     */
    async getChangeCount(staged = false) {
        const rows = staged
            ? await this.stagedChanges$$
            : await this.changes$$;
        if (rows.length < 1) {
            return 0;
        }
        const count = await rows[0].$(this.locators.changeCount);
        return +await count.getText();
    }
};
ScmProvider = __decorate([
    PageDecorator(ScmViewLocators)
], ScmProvider);
export { ScmProvider };
/**
 * Page object representing a SCM change tree item
 *
 * @category Sidebar
 */
let ScmChange = class ScmChange extends ElementWithContextMenu {
    constructor(locators, row, provider) {
        super(locators, row, provider.elem);
        this.provider = provider;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get label as a string
     */
    async getLabel() {
        return this.changeLabel$.getText();
    }
    /**
     * Get description as a string
     */
    async getDescription() {
        const desc = await this.changeDesc$$;
        if (desc.length < 1) {
            return '';
        }
        return desc[0].getText();
    }
    /**
     * Get the status string (e.g. 'Modified')
     */
    async getStatus() {
        const res = await this.resource$;
        const status = await res.getAttribute('data-tooltip');
        if (status && status.length > 0) {
            return status;
        }
        return 'folder';
    }
    /**
     * Find if the item is expanded
     * @returns promise resolving to true if change is expanded, to false otherwise
     */
    async isExpanded() {
        const twisties = await this.expand$$;
        if (twisties.length < 1) {
            return true;
        }
        return (await twisties[0].getAttribute('class')).indexOf('collapsed') < 0;
    }
    /**
     * Expand or collapse a change item if possible, only works for folders in hierarchical view mode
     * @param expand true to expand the item, false to collapse
     * @returns promise resolving to true if the item changed state, to false otherwise
     */
    async toggleExpand(expand) {
        if (await this.isExpanded() !== expand) {
            await this.elem.click();
            return true;
        }
        return false;
    }
    /**
     * Find and click an action button available to a given change tree item
     * @param title title of the action button (e.g 'Stage Changes')
     * @returns promise resolving to true if the action was performed successfully,
     * false if the given button does not exist
     */
    async takeAction(title) {
        await this.elem.moveTo();
        const actions = await this.action$$;
        const names = await Promise.all(actions.map((action) => action.getAttribute('title')));
        const index = names.findIndex((item) => item === title);
        if (index > -1) {
            await actions[index].click();
            return true;
        }
        return false;
    }
};
ScmChange = __decorate([
    PageDecorator(ScmViewLocators)
], ScmChange);
export { ScmChange };
/**
 * More Action
 *
 * @category Sidebar
 */
let MoreAction = class MoreAction extends ElementWithContextMenu {
    constructor(locators, scm) {
        super(locators, locators.ScmView.more, scm.elem);
        this.scm = scm;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    async openContextMenu() {
        await this.elem.click();
        const shadowRootHost = await this.scm.elem.$$('shadow-root-host');
        await browser.keys('Escape');
        if (shadowRootHost.length > 0) {
            if (await this.elem.getAttribute('aria-expanded') !== 'true') {
                await this.elem.click();
            }
            const shadowRoot = $(await browser.execute('return arguments[0].shadowRoot', shadowRootHost[0]));
            return new ContextMenu(this.locatorMap, shadowRoot).wait();
        }
        return super.openContextMenu();
    }
};
MoreAction = __decorate([
    PageDecorator(ScmViewLocators)
], MoreAction);
export { MoreAction };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NtVmlldy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWdlb2JqZWN0cy9zaWRlYmFyL3NjbS9TY21WaWV3LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxHQUFHLEVBQTJCLE1BQU0sYUFBYSxDQUFBO0FBRTFELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQTtBQUMvQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUE7QUFDNUMsT0FBTyxFQUNILHNCQUFzQixFQUFvQixhQUFhLEVBQWtCLFFBQVEsRUFDcEYsTUFBTSxnQkFBZ0IsQ0FBQTtBQUN2QixPQUFPLEVBQUUsT0FBTyxJQUFJLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFBO0FBQ3hFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQTtBQUcvQzs7OztHQUlHO0FBRUksSUFBTSxPQUFPLEdBQWIsTUFBTSxPQUFRLFNBQVEsV0FBbUM7SUFBekQ7O1FBQ0g7O1dBRUc7UUFDSSxlQUFVLEdBQUcsU0FBa0IsQ0FBQTtJQXlDMUMsQ0FBQztJQXZDRzs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLFdBQVcsQ0FBRSxLQUFjO1FBQzdCLE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFBO1FBQzNDLElBQUksQ0FBQyxLQUFLLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUNuQyxPQUFPLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUN2QixDQUFDO1FBQ0QsTUFBTSxLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQTtRQUMvRSxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLEtBQUssS0FBSyxDQUFDLENBQUE7UUFFdkQsT0FBTyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFBO0lBQ3BELENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsWUFBWTtRQUNkLE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixDQUFBO1FBQzNDLE1BQU0sUUFBUSxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUMzRyxpRUFBaUU7UUFDakUsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsT0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQTtJQUN6RyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLG9CQUFvQjtRQUN0QixNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLENBQUE7UUFDdkMsSUFBSSxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3JCLE1BQU0sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFBO1lBQ3hCLE9BQU8sSUFBSSxDQUFBO1FBQ2YsQ0FBQztRQUNELE9BQU8sS0FBSyxDQUFBO0lBQ2hCLENBQUM7Q0FDSixDQUFBO0FBN0NZLE9BQU87SUFEbkIsYUFBYSxDQUFDLGVBQWUsQ0FBQztHQUNsQixPQUFPLENBNkNuQjs7QUFHRDs7Ozs7R0FLRztBQUVJLElBQU0sV0FBVyxHQUFqQixNQUFNLFdBQVksU0FBUSxRQUFnQztJQUs3RCxZQUNJLFFBQTBCLEVBQzFCLE9BQXFELEVBQzlDLElBQWE7UUFFcEIsS0FBSyxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBRjVCLFNBQUksR0FBSixJQUFJLENBQVM7UUFQeEI7O1dBRUc7UUFDSSxlQUFVLEdBQUcsU0FBa0IsQ0FBQTtJQU90QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUE7SUFDeEQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFBO0lBQ3ZELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLFVBQVUsQ0FBRSxLQUFhO1FBQzNCLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQTtRQUN6QyxJQUFJLE9BQU8sR0FBbUQsRUFBRSxDQUFBO1FBQ2hFLElBQUksQ0FBQyxNQUFNLE1BQU0sQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUM5RCxPQUFPLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUN4RixDQUFDO2FBQU0sQ0FBQztZQUNKLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQTtZQUN4QixPQUFPLEdBQUcsTUFBTSxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUEwRCxDQUFBO1FBQzVHLENBQUM7UUFDRCxNQUFNLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDdEYsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFBO1FBRXZELElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDYixNQUFNLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQTtZQUM1QixPQUFPLElBQUksQ0FBQTtRQUNmLENBQUM7UUFDRCxPQUFPLEtBQUssQ0FBQTtJQUNoQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLGVBQWU7UUFDakIsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFBO1FBQ3pDLElBQUksQ0FBQyxNQUFNLE1BQU0sQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUM5RCxPQUFPLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFBO1FBQ3ZFLENBQUM7UUFDRCxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUE7UUFDeEIsT0FBTyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFBO0lBQ2xFLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGFBQWEsQ0FBRSxPQUFlO1FBQ2hDLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQTtRQUNwQyxNQUFNLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQTtRQUN4QixNQUFNLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUE7UUFDN0IsTUFBTSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQzthQUN0QixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7YUFDN0IsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO2FBQ3pCLE9BQU8sRUFBRSxDQUFBO0lBQ2xCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLFVBQVUsQ0FBRSxNQUFNLEdBQUcsS0FBSztRQUM1QixNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUE7UUFDakQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFBO1FBRW5ELElBQUksUUFBUSxHQUFtRCxFQUFFLENBQUE7UUFDakUsSUFBSSxPQUFPLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDZCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtZQUNWLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFtQixDQUFBO1lBQ3pDLEtBQUssTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxRQUFRLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQztnQkFDN0MsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUE7Z0JBQ25ELElBQUksTUFBTSxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssS0FBSyxFQUFFLENBQUM7b0JBQ2pDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFBO29CQUNiLE1BQUs7Z0JBQ1QsQ0FBQztZQUNMLENBQUM7WUFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDUixPQUFPLEVBQUUsQ0FBQTtZQUNiLENBQUM7WUFDRCxRQUFRLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFBO1FBQzdDLENBQUM7UUFDRCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQ2QsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FDdEIsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQ3ZELENBQUMsQ0FDTCxDQUFBO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsY0FBYyxDQUFFLE1BQU0sR0FBRyxLQUFLO1FBQ2hDLE1BQU0sSUFBSSxHQUFHLE1BQU07WUFDZixDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsZUFBZTtZQUM1QixDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFBO1FBRTFCLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUNsQixPQUFPLENBQUMsQ0FBQTtRQUNaLENBQUM7UUFDRCxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQTtRQUN4RCxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUE7SUFDakMsQ0FBQztDQUNKLENBQUE7QUEvSFksV0FBVztJQUR2QixhQUFhLENBQUMsZUFBZSxDQUFDO0dBQ2xCLFdBQVcsQ0ErSHZCOztBQUdEOzs7O0dBSUc7QUFFSSxJQUFNLFNBQVMsR0FBZixNQUFNLFNBQVUsU0FBUSxzQkFBOEM7SUFNekUsWUFDSSxRQUEwQixFQUMxQixHQUFpRCxFQUMxQyxRQUFxQjtRQUU1QixLQUFLLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUE7UUFGNUIsYUFBUSxHQUFSLFFBQVEsQ0FBYTtRQVJoQzs7V0FFRztRQUNJLGVBQVUsR0FBRyxTQUFrQixDQUFBO0lBUXRDLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFBO0lBQ3RDLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxjQUFjO1FBQ2hCLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQTtRQUNwQyxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDbEIsT0FBTyxFQUFFLENBQUE7UUFDYixDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUE7SUFDNUIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLFNBQVM7UUFDWCxNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUE7UUFDaEMsTUFBTSxNQUFNLEdBQUcsTUFBTSxHQUFHLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFBO1FBRXJELElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDOUIsT0FBTyxNQUFNLENBQUE7UUFDakIsQ0FBQztRQUNELE9BQU8sUUFBUSxDQUFBO0lBQ25CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsVUFBVTtRQUNaLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQTtRQUNwQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDdEIsT0FBTyxJQUFJLENBQUE7UUFDZixDQUFDO1FBQ0QsT0FBTyxDQUFDLE1BQU0sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDN0UsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsWUFBWSxDQUFFLE1BQWU7UUFDL0IsSUFBSSxNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsS0FBSyxNQUFNLEVBQUUsQ0FBQztZQUNyQyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUE7WUFDdkIsT0FBTyxJQUFJLENBQUE7UUFDZixDQUFDO1FBQ0QsT0FBTyxLQUFLLENBQUE7SUFDaEIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLFVBQVUsQ0FBRSxLQUFhO1FBQzNCLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQTtRQUN4QixNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUE7UUFDbkMsTUFBTSxLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQ3RGLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksS0FBSyxLQUFLLENBQUMsQ0FBQTtRQUV2RCxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2IsTUFBTSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUE7WUFDNUIsT0FBTyxJQUFJLENBQUE7UUFDZixDQUFDO1FBQ0QsT0FBTyxLQUFLLENBQUE7SUFDaEIsQ0FBQztDQUNKLENBQUE7QUF4RlksU0FBUztJQURyQixhQUFhLENBQUMsZUFBZSxDQUFDO0dBQ2xCLFNBQVMsQ0F3RnJCOztBQUdEOzs7O0dBSUc7QUFFSSxJQUFNLFVBQVUsR0FBaEIsTUFBTSxVQUFXLFNBQVEsc0JBQThDO0lBTTFFLFlBQ0ksUUFBMEIsRUFDbkIsR0FBMEI7UUFFakMsS0FBSyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLElBQWMsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUE7UUFGbkQsUUFBRyxHQUFILEdBQUcsQ0FBdUI7UUFQckM7O1dBRUc7UUFDSSxlQUFVLEdBQUcsU0FBa0IsQ0FBQTtJQU90QyxDQUFDO0lBRUQsS0FBSyxDQUFDLGVBQWU7UUFDakIsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFBO1FBQ3ZCLE1BQU0sY0FBYyxHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLENBQUE7UUFDakUsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBRTVCLElBQUksY0FBYyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUM1QixJQUFJLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLEtBQUssTUFBTSxFQUFFLENBQUM7Z0JBQzNELE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQTtZQUMzQixDQUFDO1lBQ0QsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLE1BQU0sT0FBTyxDQUFDLE9BQU8sQ0FBQyxnQ0FBZ0MsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQ2hHLE9BQU8sSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQTtRQUM5RCxDQUFDO1FBQ0QsT0FBTyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUE7SUFDbEMsQ0FBQztDQUNKLENBQUE7QUEzQlksVUFBVTtJQUR0QixhQUFhLENBQUMsZUFBZSxDQUFDO0dBQ2xCLFVBQVUsQ0EyQnRCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgS2V5LCBDaGFpbmFibGVQcm9taXNlRWxlbWVudCB9IGZyb20gJ3dlYmRyaXZlcmlvJ1xuXG5pbXBvcnQgeyBTaWRlQmFyVmlldyB9IGZyb20gJy4uL1NpZGVCYXJWaWV3LmpzJ1xuaW1wb3J0IHsgQ29udGV4dE1lbnUgfSBmcm9tICcuLi8uLi9pbmRleC5qcydcbmltcG9ydCB7XG4gICAgRWxlbWVudFdpdGhDb250ZXh0TWVudSwgVlNDb2RlTG9jYXRvck1hcCwgUGFnZURlY29yYXRvciwgSVBhZ2VEZWNvcmF0b3IsIEJhc2VQYWdlXG59IGZyb20gJy4uLy4uL3V0aWxzLmpzJ1xuaW1wb3J0IHsgU2NtVmlldyBhcyBTY21WaWV3TG9jYXRvcnMgfSBmcm9tICcuLi8uLi8uLi9sb2NhdG9ycy8xLjczLjAuanMnXG5pbXBvcnQgeyBDTURfS0VZIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFNjbVZpZXcgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7IH1cbi8qKlxuICogUGFnZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBTb3VyY2UgQ29udHJvbCB2aWV3XG4gKlxuICogQGNhdGVnb3J5IFNpZGViYXJcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoU2NtVmlld0xvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFNjbVZpZXcgZXh0ZW5kcyBTaWRlQmFyVmlldzx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTY21WaWV3JyBhcyBjb25zdFxuXG4gICAgLyoqXG4gICAgICogR2V0IFNDTSBwcm92aWRlciAocmVwb3NpdG9yeSkgYnkgdGl0bGVcbiAgICAgKiBAcGFyYW0gdGl0bGUgbmFtZSBvZiB0aGUgcmVwb3NpdG9yeVxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIFNjbVByb3ZpZGVyIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb3ZpZGVyICh0aXRsZT86IHN0cmluZyk6IFByb21pc2U8U2NtUHJvdmlkZXIgfCB1bmRlZmluZWQ+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJzID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcnMoKVxuICAgICAgICBpZiAoIXRpdGxlIHx8IHByb3ZpZGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlcnNbMF1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb3ZpZGVycy5tYXAoYXN5bmMgKGl0ZW0pID0+IGl0ZW0uZ2V0VGl0bGUoKSkpXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuZmluZEluZGV4KChuYW1lKSA9PiBuYW1lID09PSB0aXRsZSlcblxuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IHByb3ZpZGVyc1tpbmRleF0gOiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIFNDTSBwcm92aWRlcnNcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBTY21Qcm92aWRlciBhcnJheVxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb3ZpZGVycyAoKTogUHJvbWlzZTxTY21Qcm92aWRlcltdPiB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCB0aGlzLnByb3ZpZGVySGVhZGVyJCRcbiAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbChoZWFkZXJzLm1hcChhc3luYyAoaGVhZGVyKSA9PiBoZWFkZXIuJCh0aGlzLmxvY2F0b3JzLnByb3ZpZGVyUmVsYXRpdmUpKSlcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHNlY3Rpb25zLm1hcCgoc2VjdGlvbikgPT4gbmV3IFNjbVByb3ZpZGVyKHRoaXMubG9jYXRvck1hcCwgc2VjdGlvbiBhcyBhbnksIHRoaXMpKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHJlcG9zaXRvcnkgaW4gdGhlIGN1cnJlbnQgZm9sZGVyIGlmIG5vIFNDTSBwcm92aWRlciBpcyBmb3VuZFxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGFjdGlvbiB3YXMgY29tcGxldGVkIHN1Y2Nlc2Z1bGx5LCBmYWxzZSBpZiBhIHByb3ZpZGVyIGFscmVhZHkgZXhpc3RzXG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhbGl6ZVJlcG9zaXRvcnkgKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBidXR0b25zID0gYXdhaXQgdGhpcy5pbml0QnV0dG9uJCRcbiAgICAgICAgaWYgKGJ1dHRvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgYnV0dG9uc1swXS5jbGljaygpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY21Qcm92aWRlciBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBTY21WaWV3TG9jYXRvcnM+IHsgfVxuLyoqXG4gKiBQYWdlIG9iamVjdCByZXByZXNlbnRpbmcgYSByZXBvc2l0b3J5IGluIHRoZSBzb3VyY2UgY29udHJvbCB2aWV3XG4gKiBNYXBzIHJvdWdobHkgdG8gYSB2aWV3IHNlY3Rpb24gb2YgdGhlIHNvdXJjZSBjb250cm9sIHZpZXdcbiAqXG4gKiBAY2F0ZWdvcnkgU2lkZWJhclxuICovXG5AUGFnZURlY29yYXRvcihTY21WaWV3TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgU2NtUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUGFnZTx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTY21WaWV3JyBhcyBjb25zdFxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIGVsZW1lbnQ6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+LFxuICAgICAgICBwdWJsaWMgdmlldzogU2NtVmlld1xuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgZWxlbWVudCwgdmlldy5lbGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aXRsZSBvZiB0aGUgc2NtIHByb3ZpZGVyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGl0bGUgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyVGl0bGUkLmdldEF0dHJpYnV0ZSgnaW5uZXJIVE1MJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdHlwZSBvZiB0aGUgc2NtIHByb3ZpZGVyIChlLmcuIEdpdClcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUeXBlICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlclR5cGUkLmdldEF0dHJpYnV0ZSgnaW5uZXJIVE1MJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuIGFjdGlvbiBidXR0b24gZm9yIHRoZSBTQ00gcHJvdmlkZXIgYnkgdGl0bGUgYW5kIGNsaWNrIGl0LiAoZS5nICdDb21taXQnKVxuICAgICAqIEBwYXJhbSB0aXRsZSBUaXRsZSBvZiB0aGUgYWN0aW9uIGJ1dHRvbiB0byBjbGlja1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGFjdGlvbiBjb3VsZCBiZSBwZXJmb3JtZWQsIGZhbHNlIGlmIHRoZSBidXR0b24gZG9lc24ndCBleGlzdFxuICAgICAqL1xuICAgIGFzeW5jIHRha2VBY3Rpb24gKHRpdGxlOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy5wcm92aWRlckhlYWRlciRcbiAgICAgICAgbGV0IGFjdGlvbnM6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+W10gPSBbXVxuICAgICAgICBpZiAoKGF3YWl0IGhlYWRlci5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpLmluZGV4T2YoJ2hpZGRlbicpID4gLTEpIHtcbiAgICAgICAgICAgIGFjdGlvbnMgPSAoYXdhaXQgdGhpcy52aWV3LmdldFRpdGxlUGFydCgpLmdldEFjdGlvbnMoKSkubWFwKChhY3Rpb24pID0+IGFjdGlvbi5lbGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbGVtLm1vdmVUbygpXG4gICAgICAgICAgICBhY3Rpb25zID0gYXdhaXQgaGVhZGVyLiQkKHRoaXMubG9jYXRvcnMuYWN0aW9uKSBhcyBhbnkgYXMgQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD5bXVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWN0aW9ucy5tYXAoKGFjdGlvbikgPT4gYWN0aW9uLmdldEF0dHJpYnV0ZSgndGl0bGUnKSkpXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtID09PSB0aXRsZSlcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgYXdhaXQgYWN0aW9uc1tpbmRleF0uY2xpY2soKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIGEgY29udGV4dCBtZW51IHVzaW5nIHRoZSAnTW9yZSBBY3Rpb25zLi4uJyBidXR0b25cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIENvbnRleHRNZW51IG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIG9wZW5Nb3JlQWN0aW9ucyAoKTogUHJvbWlzZTxDb250ZXh0TWVudT4ge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0aGlzLnByb3ZpZGVySGVhZGVyJFxuICAgICAgICBpZiAoKGF3YWl0IGhlYWRlci5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpLmluZGV4T2YoJ2hpZGRlbicpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9yZUFjdGlvbih0aGlzLmxvY2F0b3JNYXAsIHRoaXMudmlldykub3BlbkNvbnRleHRNZW51KClcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmVsZW0ubW92ZVRvKClcbiAgICAgICAgcmV0dXJuIG5ldyBNb3JlQWN0aW9uKHRoaXMubG9jYXRvck1hcCwgdGhpcykub3BlbkNvbnRleHRNZW51KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxsIGluIHRoZSBtZXNzYWdlIGZpZWxkIGFuZCBzZW5kIGN0cmwvY21kICsgZW50ZXIgdG8gY29tbWl0IHRoZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgdGhlIGNvbW1pdCBtZXNzYWdlIHRvIHVzZVxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIG9uY2UgdGhlIGtleXByZXNzZXMgYXJlIHNlbnRcbiAgICAgKi9cbiAgICBhc3luYyBjb21taXRDaGFuZ2VzIChtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBhd2FpdCB0aGlzLmlucHV0RmllbGQkXG4gICAgICAgIGF3YWl0IGlucHV0LmNsZWFyVmFsdWUoKVxuICAgICAgICBhd2FpdCBpbnB1dC5hZGRWYWx1ZShtZXNzYWdlKVxuICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JylcbiAgICAgICAgICAgIC5kb3duKENNRF9LRVkpLmRvd24oS2V5LkVudGVyKVxuICAgICAgICAgICAgLnVwKENNRF9LRVkpLnVwKEtleS5FbnRlcilcbiAgICAgICAgICAgIC5wZXJmb3JtKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGFnZSBvYmplY3RzIGZvciBhbGwgdHJlZSBpdGVtcyByZXByZXNlbnRpbmcgaW5kaXZpZHVhbCBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHN0YWdlZCB3aGVuIHRydWUsIGZpbmRzIHN0YWdlZCBjaGFuZ2VzIG90aGVyd2lzZSBmaW5kcyB1bnN0YWdlZCBjaGFuZ2VzXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gU2NtQ2hhbmdlIG9iamVjdCBhcnJheVxuICAgICAqL1xuICAgIGFzeW5jIGdldENoYW5nZXMgKHN0YWdlZCA9IGZhbHNlKTogUHJvbWlzZTxTY21DaGFuZ2VbXT4ge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gYXdhaXQgdGhpcy5nZXRDaGFuZ2VDb3VudChzdGFnZWQpXG4gICAgICAgIGNvbnN0IGxhYmVsID0gc3RhZ2VkID8gJ1NUQUdFRCBDSEFOR0VTJyA6ICdDSEFOR0VTJ1xuXG4gICAgICAgIGxldCBlbGVtZW50czogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD5bXSA9IFtdXG4gICAgICAgIGlmIChjaGFuZ2VzID4gMCkge1xuICAgICAgICAgICAgbGV0IGkgPSAtMVxuICAgICAgICAgICAgZWxlbWVudHMgPSBhd2FpdCB0aGlzLmNoYW5nZUl0ZW0kJCBhcyBhbnlcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBpdGVtXSBvZiBlbGVtZW50cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXdhaXQgaXRlbS4kKHRoaXMubG9jYXRvcnMuY2hhbmdlTmFtZSlcbiAgICAgICAgICAgICAgICBpZiAoYXdhaXQgbmFtZS5nZXRUZXh0KCkgPT09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBpbmRleCArIDFcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMuc2xpY2UoaSwgaSArIGNoYW5nZXMpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgZWxlbWVudHMubWFwKChlbGVtZW50KSA9PiAoXG4gICAgICAgICAgICAgICAgbmV3IFNjbUNoYW5nZSh0aGlzLmxvY2F0b3JNYXAsIGVsZW1lbnQsIHRoaXMpLndhaXQoKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGNoYW5nZXMgZm9yIGEgZ2l2ZW4gc2VjdGlvblxuICAgICAqIEBwYXJhbSBzdGFnZWQgd2hlbiB0cnVlLCBjb3VudHMgdGhlIHN0YWdlZCBjaGFuZ2VzLCB1bnN0YWdlZCBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBudW1iZXIgb2YgY2hhbmdlcyBpbiB0aGUgZ2l2ZW4gc3Vic2VjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGdldENoYW5nZUNvdW50IChzdGFnZWQgPSBmYWxzZSk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBzdGFnZWRcbiAgICAgICAgICAgID8gYXdhaXQgdGhpcy5zdGFnZWRDaGFuZ2VzJCRcbiAgICAgICAgICAgIDogYXdhaXQgdGhpcy5jaGFuZ2VzJCRcblxuICAgICAgICBpZiAocm93cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgcm93c1swXS4kKHRoaXMubG9jYXRvcnMuY2hhbmdlQ291bnQpXG4gICAgICAgIHJldHVybiArYXdhaXQgY291bnQuZ2V0VGV4dCgpXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjbUNoYW5nZSBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBTY21WaWV3TG9jYXRvcnM+IHsgfVxuLyoqXG4gKiBQYWdlIG9iamVjdCByZXByZXNlbnRpbmcgYSBTQ00gY2hhbmdlIHRyZWUgaXRlbVxuICpcbiAqIEBjYXRlZ29yeSBTaWRlYmFyXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFNjbVZpZXdMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBTY21DaGFuZ2UgZXh0ZW5kcyBFbGVtZW50V2l0aENvbnRleHRNZW51PHR5cGVvZiBTY21WaWV3TG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1NjbVZpZXcnIGFzIGNvbnN0XG5cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLFxuICAgICAgICByb3c6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+LFxuICAgICAgICBwdWJsaWMgcHJvdmlkZXI6IFNjbVByb3ZpZGVyXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCByb3csIHByb3ZpZGVyLmVsZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGxhYmVsIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TGFiZWwgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUxhYmVsJC5nZXRUZXh0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGVzY3JpcHRpb24gYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXNjcmlwdGlvbiAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgZGVzYyA9IGF3YWl0IHRoaXMuY2hhbmdlRGVzYyQkXG4gICAgICAgIGlmIChkZXNjLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjWzBdLmdldFRleHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhdHVzIHN0cmluZyAoZS5nLiAnTW9kaWZpZWQnKVxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXR1cyAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5yZXNvdXJjZSRcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgcmVzLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwJylcblxuICAgICAgICBpZiAoc3RhdHVzICYmIHN0YXR1cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdmb2xkZXInXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBpZiB0aGUgaXRlbSBpcyBleHBhbmRlZFxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgY2hhbmdlIGlzIGV4cGFuZGVkLCB0byBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBpc0V4cGFuZGVkICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgdHdpc3RpZXMgPSBhd2FpdCB0aGlzLmV4cGFuZCQkXG4gICAgICAgIGlmICh0d2lzdGllcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYXdhaXQgdHdpc3RpZXNbMF0uZ2V0QXR0cmlidXRlKCdjbGFzcycpKS5pbmRleE9mKCdjb2xsYXBzZWQnKSA8IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmQgb3IgY29sbGFwc2UgYSBjaGFuZ2UgaXRlbSBpZiBwb3NzaWJsZSwgb25seSB3b3JrcyBmb3IgZm9sZGVycyBpbiBoaWVyYXJjaGljYWwgdmlldyBtb2RlXG4gICAgICogQHBhcmFtIGV4cGFuZCB0cnVlIHRvIGV4cGFuZCB0aGUgaXRlbSwgZmFsc2UgdG8gY29sbGFwc2VcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byB0cnVlIGlmIHRoZSBpdGVtIGNoYW5nZWQgc3RhdGUsIHRvIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFzeW5jIHRvZ2dsZUV4cGFuZCAoZXhwYW5kOiBib29sZWFuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmlzRXhwYW5kZWQoKSAhPT0gZXhwYW5kKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVsZW0uY2xpY2soKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBjbGljayBhbiBhY3Rpb24gYnV0dG9uIGF2YWlsYWJsZSB0byBhIGdpdmVuIGNoYW5nZSB0cmVlIGl0ZW1cbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIGFjdGlvbiBidXR0b24gKGUuZyAnU3RhZ2UgQ2hhbmdlcycpXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiB0aGUgYWN0aW9uIHdhcyBwZXJmb3JtZWQgc3VjY2Vzc2Z1bGx5LFxuICAgICAqIGZhbHNlIGlmIHRoZSBnaXZlbiBidXR0b24gZG9lcyBub3QgZXhpc3RcbiAgICAgKi9cbiAgICBhc3luYyB0YWtlQWN0aW9uICh0aXRsZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuZWxlbS5tb3ZlVG8oKVxuICAgICAgICBjb25zdCBhY3Rpb25zID0gYXdhaXQgdGhpcy5hY3Rpb24kJFxuICAgICAgICBjb25zdCBuYW1lcyA9IGF3YWl0IFByb21pc2UuYWxsKGFjdGlvbnMubWFwKChhY3Rpb24pID0+IGFjdGlvbi5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykpKVxuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbSA9PT0gdGl0bGUpXG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGF3YWl0IGFjdGlvbnNbaW5kZXhdLmNsaWNrKClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vcmVBY3Rpb24gZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7IH1cbi8qKlxuICogTW9yZSBBY3Rpb25cbiAqXG4gKiBAY2F0ZWdvcnkgU2lkZWJhclxuICovXG5AUGFnZURlY29yYXRvcihTY21WaWV3TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgTW9yZUFjdGlvbiBleHRlbmRzIEVsZW1lbnRXaXRoQ29udGV4dE1lbnU8dHlwZW9mIFNjbVZpZXdMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnU2NtVmlldycgYXMgY29uc3RcblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIHB1YmxpYyBzY206IFNjbVByb3ZpZGVyIHwgU2NtVmlld1xuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgbG9jYXRvcnMuU2NtVmlldy5tb3JlIGFzIHN0cmluZywgc2NtLmVsZW0pXG4gICAgfVxuXG4gICAgYXN5bmMgb3BlbkNvbnRleHRNZW51ICgpOiBQcm9taXNlPENvbnRleHRNZW51PiB7XG4gICAgICAgIGF3YWl0IHRoaXMuZWxlbS5jbGljaygpXG4gICAgICAgIGNvbnN0IHNoYWRvd1Jvb3RIb3N0ID0gYXdhaXQgdGhpcy5zY20uZWxlbS4kJCgnc2hhZG93LXJvb3QtaG9zdCcpXG4gICAgICAgIGF3YWl0IGJyb3dzZXIua2V5cygnRXNjYXBlJylcblxuICAgICAgICBpZiAoc2hhZG93Um9vdEhvc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGF3YWl0IHRoaXMuZWxlbS5nZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKSAhPT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbGVtLmNsaWNrKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSAkKGF3YWl0IGJyb3dzZXIuZXhlY3V0ZSgncmV0dXJuIGFyZ3VtZW50c1swXS5zaGFkb3dSb290Jywgc2hhZG93Um9vdEhvc3RbMF0pKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250ZXh0TWVudSh0aGlzLmxvY2F0b3JNYXAsIHNoYWRvd1Jvb3QpLndhaXQoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5vcGVuQ29udGV4dE1lbnUoKVxuICAgIH1cbn1cbiJdfQ==