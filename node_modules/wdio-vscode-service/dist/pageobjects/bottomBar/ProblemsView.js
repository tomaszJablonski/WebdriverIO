var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { BottomBarPanel } from '../index.js';
import { BasePage, ElementWithContextMenu, PageDecorator } from '../utils.js';
import { ProblemsView as ProblemsViewLocators, Marker as MarkerLocators } from '../../locators/1.73.0.js';
/**
 * Problems view in the bottom panel.
 *
 * ```ts
 * const bottomBar = workbench.getBottomBar()
 * const outputView = await bottomBar.openProblemsView()
 * console.log(await outputView.setFilter('Error'))
 * ```
 *
 * @category BottomBar
 */
let ProblemsView = class ProblemsView extends BasePage {
    constructor(locators, panel = new BottomBarPanel(locators)) {
        super(locators);
        this.panel = panel;
        /**
         * @private
         */
        this.locatorKey = 'ProblemsView';
        this.setParentElement(this.panel.elem);
    }
    /**
     * Set the filter using the input box on the problems view
     * @param pattern filter to use, preferably a glob pattern
     * @returns Promise resolving when the filter pattern is filled in
     */
    async setFilter(pattern) {
        const filterField = await this.clearFilter();
        await filterField.setValue(pattern);
    }
    /**
     * Clear all filters
     * @returns Promise resolving to the filter field WebElement
     */
    async clearFilter() {
        const filterField = await this.panel.elem
            .$(this.locatorMap.BottomBarPanel.actions)
            .$(this.locators.markersFilter)
            .$(this.locators.input);
        await filterField.clearValue();
        return filterField;
    }
    /**
     * Collapse all collapsible markers in the problems view
     * @returns Promise resolving when the collapse all button is pressed
     */
    async collapseAll() {
        const button = await this.panel.elem
            .$(this.locatorMap.BottomBarPanel.actions)
            .$(this.locators.collapseAll);
        await button.click();
    }
    /**
     * @deprecated The method should not be used and getAllVisibleMarkers() should be used instead.
     */
    async getAllMarkers() {
        return this.getAllVisibleMarkers(MarkerType.Any);
    }
    /**
     * Get all visible markers from the problems view with the given type.
     * Warning: this only returns the markers that are visible, and not the
     * entire list, so calls to this function may change depending on the
     * environment  in which the tests are running in.
     * To get all markers regardless of type, use MarkerType.Any
     * @param type type of markers to retrieve
     * @returns Promise resolving to array of Marker objects
     */
    async getAllVisibleMarkers(type) {
        const markers = [];
        const elements = await this.markerRow$$;
        for (const element of elements) {
            const isExpandable = typeof (await element.getAttribute('aria-expanded')) === 'string';
            if (isExpandable) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                const marker = await new Marker(this.locatorMap, element, this).wait();
                if (type === MarkerType.Any || type === await marker.getType()) {
                    markers.push(marker);
                }
                continue;
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            markers[markers.length - 1].problems.push(new Problem(this.locatorMap, element));
        }
        return markers;
    }
    /**
     * Gets the count badge
     * @returns Promise resolving to the WebElement representing the count badge
     */
    getCountBadge() {
        return this.changeCount$;
    }
};
ProblemsView = __decorate([
    PageDecorator(ProblemsViewLocators)
], ProblemsView);
export { ProblemsView };
/**
 * Page object for marker in problems view
 *
 * @category BottomBar
 */
let Marker = class Marker extends ElementWithContextMenu {
    constructor(locators, element, view) {
        super(locators, element, view.elem);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'Marker';
        this.problems = [];
    }
    /**
     * Get the type of the marker
     * Possible types are: File, Error, Warning
     * @returns Promise resolving to a MarkerType
     */
    async getType() {
        const twist = await this.elem.$(this.locatorMap.ProblemsView.markerTwistie);
        if ((await twist.getAttribute('class')).indexOf('collapsible') > -1) {
            return MarkerType.File;
        }
        const text = await this.getText();
        if (text.startsWith('Error')) {
            return MarkerType.Error;
        }
        return MarkerType.Warning;
    }
    /**
     * Get the name of the file that has problems
     * @returns name of file containing problems
     */
    getFileName() {
        return this.fileName$.getText();
    }
    /**
     * Get the error count of the file that has problems
     * @returns error count of file containing problems
     */
    getProblemCount() {
        return this.problemCount$.getText();
    }
    /**
     * Get the full text of the marker
     * @returns Promise resolving to marker text
     */
    async getText() {
        return this.elem.getAttribute(this.locators.rowLabel);
    }
    /**
     * Expand/Collapse the marker if possible
     * @param expand true to expand, false to collapse
     * @returns Promise resolving when the expand/collapse twistie is clicked
     */
    async toggleExpand(expand) {
        const klass = await this.markerTwistie$.getAttribute('class');
        if ((klass.indexOf('collapsed') > -1) === expand) {
            await this.elem.click();
        }
    }
};
Marker = __decorate([
    PageDecorator(MarkerLocators)
], Marker);
export { Marker };
/**
 * Page object for marker in problems view
 *
 * @category BottomBar
 */
let Problem = class Problem extends ElementWithContextMenu {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'Marker';
    }
    /**
     * Problem details
     * @returns problem description
     */
    getText() {
        return this.detailsText$.getText();
    }
    /**
     * Type of file where the problem is located
     * @returns source file type
     */
    getSource() {
        return this.detailsSource$.getText();
    }
    /**
     * Location problem
     * @returns location of error as Array [line, column]
     */
    async getLocation() {
        const locationText = await this.detailsLine$.getText();
        return locationText
            .slice(1, -1)
            .split(',')
            .map((loc) => parseInt(loc.split(' ').pop(), 10));
    }
    /**
     * Get the type of the marker
     * Possible types are: File, Error, Warning
     * @returns Promise resolving to a MarkerType
     */
    async getType() {
        const label = await this.elem.getAttribute('aria-label');
        if (!label) {
            return MarkerType.Unknown;
        }
        if (label.startsWith('Error')) {
            return MarkerType.Error;
        }
        return MarkerType.Warning;
    }
};
Problem = __decorate([
    PageDecorator(MarkerLocators)
], Problem);
export { Problem };
/**
 * Possible types of markers
 *  - File = expandable item representing a file
 *  - Error = an error marker
 *  - Warning = a warning marker
 *  - Any = any of the above
 *
 * @hidden
 */
export var MarkerType;
(function (MarkerType) {
    MarkerType["File"] = "file";
    MarkerType["Unknown"] = "unknown";
    MarkerType["Error"] = "error";
    MarkerType["Warning"] = "warning";
    MarkerType["Any"] = "any";
})(MarkerType || (MarkerType = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvYmxlbXNWaWV3LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3BhZ2VvYmplY3RzL2JvdHRvbUJhci9Qcm9ibGVtc1ZpZXcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGFBQWEsQ0FBQTtBQUM1QyxPQUFPLEVBQ0gsUUFBUSxFQUFFLHNCQUFzQixFQUFFLGFBQWEsRUFDbEQsTUFBTSxhQUFhLENBQUE7QUFDcEIsT0FBTyxFQUFFLFlBQVksSUFBSSxvQkFBb0IsRUFBRSxNQUFNLElBQUksY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUE7QUFHekc7Ozs7Ozs7Ozs7R0FVRztBQUVJLElBQU0sWUFBWSxHQUFsQixNQUFNLFlBQWEsU0FBUSxRQUFxQztJQU1uRSxZQUNJLFFBQTBCLEVBQ25CLFFBQVEsSUFBSSxjQUFjLENBQUMsUUFBUSxDQUFDO1FBRTNDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUZSLFVBQUssR0FBTCxLQUFLLENBQStCO1FBUC9DOztXQUVHO1FBQ0ksZUFBVSxHQUFHLGNBQXVCLENBQUE7UUFPdkMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUE7SUFDMUMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsU0FBUyxDQUFFLE9BQWU7UUFDNUIsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUE7UUFDNUMsTUFBTSxXQUFXLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQ3ZDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsV0FBVztRQUNiLE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJO2FBQ3BDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxPQUFpQixDQUFDO2FBQ25ELENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQzthQUM5QixDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUMzQixNQUFNLFdBQVcsQ0FBQyxVQUFVLEVBQUUsQ0FBQTtRQUM5QixPQUFPLFdBQVcsQ0FBQTtJQUN0QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLFdBQVc7UUFDYixNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSTthQUMvQixDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsT0FBaUIsQ0FBQzthQUNuRCxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQTtRQUNqQyxNQUFNLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQTtJQUN4QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQTtJQUNwRCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxLQUFLLENBQUMsb0JBQW9CLENBQUUsSUFBZ0I7UUFDeEMsTUFBTSxPQUFPLEdBQWEsRUFBRSxDQUFBO1FBQzVCLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQTtRQUN2QyxLQUFLLE1BQU0sT0FBTyxJQUFJLFFBQVEsRUFBRSxDQUFDO1lBQzdCLE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxNQUFNLE9BQU8sQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLENBQUMsS0FBSyxRQUFRLENBQUE7WUFDdEYsSUFBSSxZQUFZLEVBQUUsQ0FBQztnQkFDZixpRUFBaUU7Z0JBQ2pFLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxPQUFjLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUE7Z0JBQzdFLElBQUksSUFBSSxLQUFLLFVBQVUsQ0FBQyxHQUFHLElBQUksSUFBSSxLQUFLLE1BQU0sTUFBTSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7b0JBQzdELE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7Z0JBQ3hCLENBQUM7Z0JBQ0QsU0FBUTtZQUNaLENBQUM7WUFDRCxpRUFBaUU7WUFDakUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLE9BQWMsQ0FBQyxDQUFDLENBQUE7UUFDM0YsQ0FBQztRQUNELE9BQU8sT0FBTyxDQUFBO0lBQ2xCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFBO0lBQzVCLENBQUM7Q0FDSixDQUFBO0FBMUZZLFlBQVk7SUFEeEIsYUFBYSxDQUFDLG9CQUFvQixDQUFDO0dBQ3ZCLFlBQVksQ0EwRnhCOztBQUdEOzs7O0dBSUc7QUFFSSxJQUFNLE1BQU0sR0FBWixNQUFNLE1BQU8sU0FBUSxzQkFBNkM7SUFPckUsWUFDSSxRQUEwQixFQUMxQixPQUFxRCxFQUM5QyxJQUFrQjtRQUV6QixLQUFLLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7UUFGNUIsU0FBSSxHQUFKLElBQUksQ0FBYztRQVQ3Qjs7V0FFRztRQUNJLGVBQVUsR0FBRyxRQUFpQixDQUFBO1FBQzlCLGFBQVEsR0FBYyxFQUFFLENBQUE7SUFRL0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsT0FBTztRQUNULE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsYUFBdUIsQ0FBQyxDQUFBO1FBQ3JGLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNsRSxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUE7UUFDMUIsQ0FBQztRQUNELE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFBO1FBQ2pDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQzNCLE9BQU8sVUFBVSxDQUFDLEtBQUssQ0FBQTtRQUMzQixDQUFDO1FBRUQsT0FBTyxVQUFVLENBQUMsT0FBTyxDQUFBO0lBQzdCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFBO0lBQ25DLENBQUM7SUFFRDs7O09BR0c7SUFDSCxlQUFlO1FBQ1gsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFBO0lBQ3ZDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQTtJQUN6RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxZQUFZLENBQUUsTUFBZTtRQUMvQixNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFBO1FBQzdELElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxFQUFFLENBQUM7WUFDL0MsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFBO1FBQzNCLENBQUM7SUFDTCxDQUFDO0NBQ0osQ0FBQTtBQXBFWSxNQUFNO0lBRGxCLGFBQWEsQ0FBQyxjQUFjLENBQUM7R0FDakIsTUFBTSxDQW9FbEI7O0FBR0Q7Ozs7R0FJRztBQUVJLElBQU0sT0FBTyxHQUFiLE1BQU0sT0FBUSxTQUFRLHNCQUE2QztJQUFuRTs7UUFDSDs7V0FFRztRQUNJLGVBQVUsR0FBRyxRQUFpQixDQUFBO0lBNkN6QyxDQUFDO0lBM0NHOzs7T0FHRztJQUNILE9BQU87UUFDSCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUE7SUFDdEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLENBQUE7SUFDeEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxXQUFXO1FBQ2IsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFBO1FBQ3RELE9BQU8sWUFBWTthQUNkLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDWixLQUFLLENBQUMsR0FBRyxDQUFDO2FBQ1YsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQVksRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFBO0lBQ25FLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLE9BQU87UUFDVCxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFBO1FBQ3hELElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNULE9BQU8sVUFBVSxDQUFDLE9BQU8sQ0FBQTtRQUM3QixDQUFDO1FBQ0QsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFDNUIsT0FBTyxVQUFVLENBQUMsS0FBSyxDQUFBO1FBQzNCLENBQUM7UUFDRCxPQUFPLFVBQVUsQ0FBQyxPQUFPLENBQUE7SUFDN0IsQ0FBQztDQUNKLENBQUE7QUFqRFksT0FBTztJQURuQixhQUFhLENBQUMsY0FBYyxDQUFDO0dBQ2pCLE9BQU8sQ0FpRG5COztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsTUFBTSxDQUFOLElBQVksVUFNWDtBQU5ELFdBQVksVUFBVTtJQUNsQiwyQkFBYSxDQUFBO0lBQ2IsaUNBQW1CLENBQUE7SUFDbkIsNkJBQWUsQ0FBQTtJQUNmLGlDQUFtQixDQUFBO0lBQ25CLHlCQUFXLENBQUE7QUFDZixDQUFDLEVBTlcsVUFBVSxLQUFWLFVBQVUsUUFNckIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENoYWluYWJsZVByb21pc2VFbGVtZW50IH0gZnJvbSAnd2ViZHJpdmVyaW8nXG5cbmltcG9ydCB7IEJvdHRvbUJhclBhbmVsIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQge1xuICAgIEJhc2VQYWdlLCBFbGVtZW50V2l0aENvbnRleHRNZW51LCBQYWdlRGVjb3JhdG9yLCBJUGFnZURlY29yYXRvciwgVlNDb2RlTG9jYXRvck1hcFxufSBmcm9tICcuLi91dGlscy5qcydcbmltcG9ydCB7IFByb2JsZW1zVmlldyBhcyBQcm9ibGVtc1ZpZXdMb2NhdG9ycywgTWFya2VyIGFzIE1hcmtlckxvY2F0b3JzIH0gZnJvbSAnLi4vLi4vbG9jYXRvcnMvMS43My4wLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb2JsZW1zVmlldyBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBQcm9ibGVtc1ZpZXdMb2NhdG9ycz4ge31cbi8qKlxuICogUHJvYmxlbXMgdmlldyBpbiB0aGUgYm90dG9tIHBhbmVsLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBib3R0b21CYXIgPSB3b3JrYmVuY2guZ2V0Qm90dG9tQmFyKClcbiAqIGNvbnN0IG91dHB1dFZpZXcgPSBhd2FpdCBib3R0b21CYXIub3BlblByb2JsZW1zVmlldygpXG4gKiBjb25zb2xlLmxvZyhhd2FpdCBvdXRwdXRWaWV3LnNldEZpbHRlcignRXJyb3InKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBCb3R0b21CYXJcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoUHJvYmxlbXNWaWV3TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgUHJvYmxlbXNWaWV3IGV4dGVuZHMgQmFzZVBhZ2U8dHlwZW9mIFByb2JsZW1zVmlld0xvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdQcm9ibGVtc1ZpZXcnIGFzIGNvbnN0XG5cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLFxuICAgICAgICBwdWJsaWMgcGFuZWwgPSBuZXcgQm90dG9tQmFyUGFuZWwobG9jYXRvcnMpXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzKVxuICAgICAgICB0aGlzLnNldFBhcmVudEVsZW1lbnQodGhpcy5wYW5lbC5lbGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmlsdGVyIHVzaW5nIHRoZSBpbnB1dCBib3ggb24gdGhlIHByb2JsZW1zIHZpZXdcbiAgICAgKiBAcGFyYW0gcGF0dGVybiBmaWx0ZXIgdG8gdXNlLCBwcmVmZXJhYmx5IGEgZ2xvYiBwYXR0ZXJuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgZmlsdGVyIHBhdHRlcm4gaXMgZmlsbGVkIGluXG4gICAgICovXG4gICAgYXN5bmMgc2V0RmlsdGVyIChwYXR0ZXJuOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSBhd2FpdCB0aGlzLmNsZWFyRmlsdGVyKClcbiAgICAgICAgYXdhaXQgZmlsdGVyRmllbGQuc2V0VmFsdWUocGF0dGVybilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZmlsdGVyc1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBmaWx0ZXIgZmllbGQgV2ViRWxlbWVudFxuICAgICAqL1xuICAgIGFzeW5jIGNsZWFyRmlsdGVyICgpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSBhd2FpdCB0aGlzLnBhbmVsLmVsZW1cbiAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvck1hcC5Cb3R0b21CYXJQYW5lbC5hY3Rpb25zIGFzIHN0cmluZylcbiAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvcnMubWFya2Vyc0ZpbHRlcilcbiAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvcnMuaW5wdXQpXG4gICAgICAgIGF3YWl0IGZpbHRlckZpZWxkLmNsZWFyVmFsdWUoKVxuICAgICAgICByZXR1cm4gZmlsdGVyRmllbGRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZSBhbGwgY29sbGFwc2libGUgbWFya2VycyBpbiB0aGUgcHJvYmxlbXMgdmlld1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGNvbGxhcHNlIGFsbCBidXR0b24gaXMgcHJlc3NlZFxuICAgICAqL1xuICAgIGFzeW5jIGNvbGxhcHNlQWxsICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gYXdhaXQgdGhpcy5wYW5lbC5lbGVtXG4gICAgICAgICAgICAuJCh0aGlzLmxvY2F0b3JNYXAuQm90dG9tQmFyUGFuZWwuYWN0aW9ucyBhcyBzdHJpbmcpXG4gICAgICAgICAgICAuJCh0aGlzLmxvY2F0b3JzLmNvbGxhcHNlQWxsKVxuICAgICAgICBhd2FpdCBidXR0b24uY2xpY2soKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFRoZSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCBnZXRBbGxWaXNpYmxlTWFya2VycygpIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsTWFya2VycyAoKTogUHJvbWlzZTxNYXJrZXJbXT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxWaXNpYmxlTWFya2VycyhNYXJrZXJUeXBlLkFueSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHZpc2libGUgbWFya2VycyBmcm9tIHRoZSBwcm9ibGVtcyB2aWV3IHdpdGggdGhlIGdpdmVuIHR5cGUuXG4gICAgICogV2FybmluZzogdGhpcyBvbmx5IHJldHVybnMgdGhlIG1hcmtlcnMgdGhhdCBhcmUgdmlzaWJsZSwgYW5kIG5vdCB0aGVcbiAgICAgKiBlbnRpcmUgbGlzdCwgc28gY2FsbHMgdG8gdGhpcyBmdW5jdGlvbiBtYXkgY2hhbmdlIGRlcGVuZGluZyBvbiB0aGVcbiAgICAgKiBlbnZpcm9ubWVudCAgaW4gd2hpY2ggdGhlIHRlc3RzIGFyZSBydW5uaW5nIGluLlxuICAgICAqIFRvIGdldCBhbGwgbWFya2VycyByZWdhcmRsZXNzIG9mIHR5cGUsIHVzZSBNYXJrZXJUeXBlLkFueVxuICAgICAqIEBwYXJhbSB0eXBlIHR5cGUgb2YgbWFya2VycyB0byByZXRyaWV2ZVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIE1hcmtlciBvYmplY3RzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsVmlzaWJsZU1hcmtlcnMgKHR5cGU6IE1hcmtlclR5cGUpOiBQcm9taXNlPE1hcmtlcltdPiB7XG4gICAgICAgIGNvbnN0IG1hcmtlcnM6IE1hcmtlcltdID0gW11cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBhd2FpdCB0aGlzLm1hcmtlclJvdyQkXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgaXNFeHBhbmRhYmxlID0gdHlwZW9mIChhd2FpdCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpKSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgIGlmIChpc0V4cGFuZGFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IGF3YWl0IG5ldyBNYXJrZXIodGhpcy5sb2NhdG9yTWFwLCBlbGVtZW50IGFzIGFueSwgdGhpcykud2FpdCgpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IE1hcmtlclR5cGUuQW55IHx8IHR5cGUgPT09IGF3YWl0IG1hcmtlci5nZXRUeXBlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKG1hcmtlcilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICBtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV0ucHJvYmxlbXMucHVzaChuZXcgUHJvYmxlbSh0aGlzLmxvY2F0b3JNYXAsIGVsZW1lbnQgYXMgYW55KSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya2Vyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvdW50IGJhZGdlXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIFdlYkVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb3VudCBiYWRnZVxuICAgICAqL1xuICAgIGdldENvdW50QmFkZ2UgKCk6IFByb21pc2U8V2ViZHJpdmVySU8uRWxlbWVudD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VDb3VudCRcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFya2VyIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIE1hcmtlckxvY2F0b3JzPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCBmb3IgbWFya2VyIGluIHByb2JsZW1zIHZpZXdcbiAqXG4gKiBAY2F0ZWdvcnkgQm90dG9tQmFyXG4gKi9cbkBQYWdlRGVjb3JhdG9yKE1hcmtlckxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIE1hcmtlciBleHRlbmRzIEVsZW1lbnRXaXRoQ29udGV4dE1lbnU8dHlwZW9mIE1hcmtlckxvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdNYXJrZXInIGFzIGNvbnN0XG4gICAgcHVibGljIHByb2JsZW1zOiBQcm9ibGVtW10gPSBbXVxuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgZWxlbWVudDogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD4sXG4gICAgICAgIHB1YmxpYyB2aWV3OiBQcm9ibGVtc1ZpZXdcbiAgICApIHtcbiAgICAgICAgc3VwZXIobG9jYXRvcnMsIGVsZW1lbnQsIHZpZXcuZWxlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhlIG1hcmtlclxuICAgICAqIFBvc3NpYmxlIHR5cGVzIGFyZTogRmlsZSwgRXJyb3IsIFdhcm5pbmdcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIE1hcmtlclR5cGVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUeXBlICgpOiBQcm9taXNlPE1hcmtlclR5cGU+IHtcbiAgICAgICAgY29uc3QgdHdpc3QgPSBhd2FpdCB0aGlzLmVsZW0uJCh0aGlzLmxvY2F0b3JNYXAuUHJvYmxlbXNWaWV3Lm1hcmtlclR3aXN0aWUgYXMgc3RyaW5nKVxuICAgICAgICBpZiAoKGF3YWl0IHR3aXN0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkuaW5kZXhPZignY29sbGFwc2libGUnKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gTWFya2VyVHlwZS5GaWxlXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHRoaXMuZ2V0VGV4dCgpXG4gICAgICAgIGlmICh0ZXh0LnN0YXJ0c1dpdGgoJ0Vycm9yJykpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXJrZXJUeXBlLkVycm9yXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWFya2VyVHlwZS5XYXJuaW5nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSBmaWxlIHRoYXQgaGFzIHByb2JsZW1zXG4gICAgICogQHJldHVybnMgbmFtZSBvZiBmaWxlIGNvbnRhaW5pbmcgcHJvYmxlbXNcbiAgICAgKi9cbiAgICBnZXRGaWxlTmFtZSAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZU5hbWUkLmdldFRleHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZXJyb3IgY291bnQgb2YgdGhlIGZpbGUgdGhhdCBoYXMgcHJvYmxlbXNcbiAgICAgKiBAcmV0dXJucyBlcnJvciBjb3VudCBvZiBmaWxlIGNvbnRhaW5pbmcgcHJvYmxlbXNcbiAgICAgKi9cbiAgICBnZXRQcm9ibGVtQ291bnQgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2JsZW1Db3VudCQuZ2V0VGV4dCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmdWxsIHRleHQgb2YgdGhlIG1hcmtlclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIG1hcmtlciB0ZXh0XG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGV4dCAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbS5nZXRBdHRyaWJ1dGUodGhpcy5sb2NhdG9ycy5yb3dMYWJlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmQvQ29sbGFwc2UgdGhlIG1hcmtlciBpZiBwb3NzaWJsZVxuICAgICAqIEBwYXJhbSBleHBhbmQgdHJ1ZSB0byBleHBhbmQsIGZhbHNlIHRvIGNvbGxhcHNlXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgZXhwYW5kL2NvbGxhcHNlIHR3aXN0aWUgaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGFzeW5jIHRvZ2dsZUV4cGFuZCAoZXhwYW5kOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGtsYXNzID0gYXdhaXQgdGhpcy5tYXJrZXJUd2lzdGllJC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcbiAgICAgICAgaWYgKChrbGFzcy5pbmRleE9mKCdjb2xsYXBzZWQnKSA+IC0xKSA9PT0gZXhwYW5kKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVsZW0uY2xpY2soKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2JsZW0gZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgTWFya2VyTG9jYXRvcnM+IHt9XG4vKipcbiAqIFBhZ2Ugb2JqZWN0IGZvciBtYXJrZXIgaW4gcHJvYmxlbXMgdmlld1xuICpcbiAqIEBjYXRlZ29yeSBCb3R0b21CYXJcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoTWFya2VyTG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgUHJvYmxlbSBleHRlbmRzIEVsZW1lbnRXaXRoQ29udGV4dE1lbnU8dHlwZW9mIE1hcmtlckxvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdNYXJrZXInIGFzIGNvbnN0XG5cbiAgICAvKipcbiAgICAgKiBQcm9ibGVtIGRldGFpbHNcbiAgICAgKiBAcmV0dXJucyBwcm9ibGVtIGRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgZ2V0VGV4dCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGFpbHNUZXh0JC5nZXRUZXh0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGZpbGUgd2hlcmUgdGhlIHByb2JsZW0gaXMgbG9jYXRlZFxuICAgICAqIEByZXR1cm5zIHNvdXJjZSBmaWxlIHR5cGVcbiAgICAgKi9cbiAgICBnZXRTb3VyY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXRhaWxzU291cmNlJC5nZXRUZXh0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2NhdGlvbiBwcm9ibGVtXG4gICAgICogQHJldHVybnMgbG9jYXRpb24gb2YgZXJyb3IgYXMgQXJyYXkgW2xpbmUsIGNvbHVtbl1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRMb2NhdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uVGV4dCA9IGF3YWl0IHRoaXMuZGV0YWlsc0xpbmUkLmdldFRleHQoKVxuICAgICAgICByZXR1cm4gbG9jYXRpb25UZXh0XG4gICAgICAgICAgICAuc2xpY2UoMSwgLTEpXG4gICAgICAgICAgICAuc3BsaXQoJywnKVxuICAgICAgICAgICAgLm1hcCgobG9jKSA9PiBwYXJzZUludChsb2Muc3BsaXQoJyAnKS5wb3AoKSBhcyBzdHJpbmcsIDEwKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhlIG1hcmtlclxuICAgICAqIFBvc3NpYmxlIHR5cGVzIGFyZTogRmlsZSwgRXJyb3IsIFdhcm5pbmdcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIE1hcmtlclR5cGVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUeXBlICgpOiBQcm9taXNlPE1hcmtlclR5cGU+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBhd2FpdCB0aGlzLmVsZW0uZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJylcbiAgICAgICAgaWYgKCFsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hcmtlclR5cGUuVW5rbm93blxuICAgICAgICB9XG4gICAgICAgIGlmIChsYWJlbC5zdGFydHNXaXRoKCdFcnJvcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gTWFya2VyVHlwZS5FcnJvclxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXJrZXJUeXBlLldhcm5pbmdcbiAgICB9XG59XG5cbi8qKlxuICogUG9zc2libGUgdHlwZXMgb2YgbWFya2Vyc1xuICogIC0gRmlsZSA9IGV4cGFuZGFibGUgaXRlbSByZXByZXNlbnRpbmcgYSBmaWxlXG4gKiAgLSBFcnJvciA9IGFuIGVycm9yIG1hcmtlclxuICogIC0gV2FybmluZyA9IGEgd2FybmluZyBtYXJrZXJcbiAqICAtIEFueSA9IGFueSBvZiB0aGUgYWJvdmVcbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBlbnVtIE1hcmtlclR5cGUge1xuICAgIEZpbGUgPSAnZmlsZScsXG4gICAgVW5rbm93biA9ICd1bmtub3duJyxcbiAgICBFcnJvciA9ICdlcnJvcicsXG4gICAgV2FybmluZyA9ICd3YXJuaW5nJyxcbiAgICBBbnkgPSAnYW55J1xufVxuIl19