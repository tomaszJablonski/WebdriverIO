var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Editor } from './Editor.js';
import { EditorView } from '../index.js';
import { PageDecorator, BasePage, sleep } from '../utils.js';
import { SettingsEditor as SettingsEditorLocators } from '../../locators/1.73.0.js';
/**
 * Page object representing the internal VSCode settings editor
 *
 * @category Editor
 */
let SettingsEditor = class SettingsEditor extends Editor {
    constructor(locators, view) {
        super(locators, view?.elem);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
        this.view = view || new EditorView(this.locatorMap);
    }
    /**
     * Search for a setting with a particular title and category.
     * Returns an appropriate Setting object if the label is found,
     * undefined otherwise.
     *
     * If your setting has nested categories (i.e `example.general.test`),
     * pass in each category as a separate string.
     *
     * @param title title of the setting
     * @param categories category of the setting
     * @returns Promise resolving to a Setting object if found, undefined otherwise
     */
    async findSetting(title, ...categories) {
        const category = categories.join(' â€º ');
        const searchBox = await this.elem.$(this.locatorMap.Editor.inputArea);
        await searchBox.setValue(`${category}: ${title}`);
        const count = await this.itemCount$;
        let textCount = await count.getText();
        await browser.waitUntil(async () => {
            await sleep(1500);
            const text = await count.getText();
            if (text !== textCount) {
                textCount = text;
                return false;
            }
            return true;
        });
        let setting;
        const items = await this.itemRow$$;
        for (const item of items) {
            try {
                return await (await this.createSetting(item, title, category)).wait();
            }
            catch (err) {
                // ignore
            }
        }
        return setting;
    }
    /**
     * Switch between settings perspectives
     * Works only if your vscode instance has both user and workspace settings available
     *
     * @param perspective User or Workspace
     * @returns Promise that resolves when the appropriate button is clicked
     */
    async switchToPerspective(perspective) {
        await this.header$
            .$(this.locators.tabs)
            .$(this.locators.actions)
            .$(this.locators.action(perspective))
            .click();
    }
    /**
     * Context menu is disabled in this editor, throw an error
     */
    openContextMenu() {
        throw new Error('Operation not supported');
    }
    async createSetting(element, title, category) {
        if (!await element.$(this.locators.settingConstructor(title, category)).isExisting()) {
            throw new Error('Setting not found');
        }
        // try a combo setting
        if (await element.$(this.locators.comboSetting).isExisting()) {
            return new ComboSetting(this.locatorMap, title, category, this);
        }
        // try text setting
        if (await element.$(this.locators.textSetting).isExisting()) {
            return new TextSetting(this.locatorMap, title, category, this);
        }
        // try checkbox setting
        if (await element.$(this.locators.checkboxSetting).isExisting()) {
            return new CheckboxSetting(this.locatorMap, title, category, this);
        }
        // try link setting
        if (await element.$(this.locators.linkButton).isExisting()) {
            return new LinkSetting(this.locatorMap, title, category, this);
        }
        throw new Error('Setting type not supported');
    }
};
SettingsEditor = __decorate([
    PageDecorator(SettingsEditorLocators)
], SettingsEditor);
export { SettingsEditor };
/**
 * Abstract item representing a Setting with title, description and
 * an input element (combo/textbox/checkbox/link)
 *
 * @category Editor
 */
export class Setting extends BasePage {
    constructor(locators, title, category, settings) {
        super(locators, locators.SettingsEditor.settingConstructor(title, category));
        this.settings = settings;
        this.title = title;
        this.category = category;
    }
    /**
     * Get the category of the setting
     * All settings are labeled as Category: Title
     */
    getCategory() {
        return this.category;
    }
    /**
     * Get description of the setting
     * @returns Promise resolving to setting description
     */
    async getDescription() {
        return this.settingDesctiption$.getText();
    }
    /**
     * Get title of the setting
     */
    getTitle() {
        return this.title;
    }
}
/**
 * Setting with a combo box
 *
 * @category Editor
 */
let ComboSetting = class ComboSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    getValue() {
        return this.comboSetting$.getAttribute('title');
    }
    async setValue(value) {
        const rows = await this.getOptions();
        for (let i = 0; i < rows.length; i += 1) {
            if ((await rows[i].getAttribute('class')).indexOf('disabled') < 0) {
                const text = await rows[i].$(this.locators.comboOption).getText();
                if (value === text) {
                    await rows[i].click();
                    return;
                }
            }
        }
    }
    /**
     * Get the labels of all options from the combo
     * @returns Promise resolving to array of string values
     */
    async getValues() {
        const values = [];
        const rows = await this.getOptions();
        for (const row of rows) {
            values.push(await row.$(this.locators.comboOption).getText());
        }
        return values;
    }
    async getOptions() {
        const menu = await this.openCombo();
        return menu.$$(this.locators.itemRow);
    }
    async openCombo() {
        const combo = await this.comboSetting$;
        const workbench = await browser.$(this.locatorMap.Workbench.elem);
        const menus = await workbench.$$(this.locatorMap.ContextMenu.contextView);
        let menu;
        if (menus.length < 1) {
            await combo.click();
            menu = await workbench.$(this.locatorMap.ContextMenu.contextView);
            return menu;
        }
        if (await menus[0].isDisplayed()) {
            await combo.click();
            // eslint-disable-next-line wdio/no-pause
            await browser.pause(200);
        }
        await combo.click();
        menu = await workbench.$(this.locatorMap.ContextMenu.contextView);
        return menu;
    }
};
ComboSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], ComboSetting);
export { ComboSetting };
/**
 * Setting with a text box input
 *
 * @category Editor
 */
let TextSetting = class TextSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    async getValue() {
        return this.textSetting$.getAttribute('value');
    }
    async setValue(value) {
        const input = await this.textSetting$;
        await input.setValue(value);
    }
};
TextSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], TextSetting);
export { TextSetting };
/**
 * Setting with a checkbox
 *
 * @category Editor
 */
let CheckboxSetting = class CheckboxSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    async getValue() {
        const checked = await this.checkboxSetting$.getAttribute(this.locators.checkboxChecked);
        if (checked === 'true') {
            return true;
        }
        return false;
    }
    async setValue(value) {
        if (await this.getValue() !== value) {
            await this.checkboxSetting$.click();
        }
    }
};
CheckboxSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], CheckboxSetting);
export { CheckboxSetting };
/**
 * Setting with no value, with a link to settings.json instead
 *
 * @category Editor
 */
let LinkSetting = class LinkSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    getValue() {
        throw new Error('Method getValue is not available for LinkSetting');
    }
    setValue() {
        throw new Error('Method setValue is not available for LinkSetting');
    }
    /**
     * Open the link that leads to the value in settings.json
     * @returns Promise resolving when the link has been clicked
     */
    async openLink() {
        await this.linkButton$.click();
    }
};
LinkSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], LinkSetting);
export { LinkSetting };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2V0dGluZ3NFZGl0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvZWRpdG9yL1NldHRpbmdzRWRpdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQWtCLE1BQU0sYUFBYSxDQUFBO0FBRXBELE9BQU8sRUFBRSxVQUFVLEVBQWUsTUFBTSxhQUFhLENBQUE7QUFFckQsT0FBTyxFQUNILGFBQWEsRUFBa0IsUUFBUSxFQUFvQixLQUFLLEVBQ25FLE1BQU0sYUFBYSxDQUFBO0FBQ3BCLE9BQU8sRUFBRSxjQUFjLElBQUksc0JBQXNCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQTtBQUduRjs7OztHQUlHO0FBRUksSUFBTSxjQUFjLEdBQXBCLE1BQU0sY0FBZSxTQUFRLE1BQXNCO0lBT3RELFlBQ0ksUUFBMEIsRUFDMUIsSUFBK0I7UUFFL0IsS0FBSyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUE7UUFWL0I7O1dBRUc7UUFDSSxlQUFVLEdBQUcsZ0JBQXlCLENBQUE7UUFRekMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQ3ZELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUUsS0FBYSxFQUFFLEdBQUcsVUFBb0I7UUFDckQsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUN2QyxNQUFNLFNBQVMsR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFNBQW1CLENBQUMsQ0FBQTtRQUMvRSxNQUFNLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxRQUFRLEtBQUssS0FBSyxFQUFFLENBQUMsQ0FB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TyxLQUFLLENBQUE7SUFDaEIsQ0FBQztJQUVELEtBQUssQ0FBQyxRQUFRLENBQUUsS0FBYztRQUMxQixJQUFJLE1BQU0sSUFBSSxDQUFDLFFBQVEsRUFBRSxLQUFLLEtBQUssRUFBRSxDQUFDO1lBQ2xDLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxDQUFBO1FBQ3ZDLENBQUM7SUFDTCxDQUFDO0NBQ0osQ0FBQTtBQW5CWSxlQUFlO0lBRDNCLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQztHQUN6QixlQUFlLENBbUIzQjs7QUFHRDs7OztHQUlHO0FBRUksSUFBTSxXQUFXLEdBQWpCLE1BQU0sV0FBWSxTQUFRLE9BQU87SUFBakM7O1FBQ0g7O1dBRUc7UUFDSSxlQUFVLEdBQUcsZ0JBQXlCLENBQUE7SUFpQmpELENBQUM7SUFmRyxRQUFRO1FBQ0osTUFBTSxJQUFJLEtBQUssQ0FBQyxrREFBa0QsQ0FBQyxDQUFBO0lBQ3ZFLENBQUM7SUFFRCxRQUFRO1FBQ0osTUFBTSxJQUFJLEtBQUssQ0FBQyxrREFBa0QsQ0FBQyxDQUFBO0lBQ3ZFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsUUFBUTtRQUNWLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQTtJQUNsQyxDQUFDO0NBQ0osQ0FBQTtBQXJCWSxXQUFXO0lBRHZCLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQztHQUN6QixXQUFXLENBcUJ2QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVkaXRvciwgRWRpdG9yTG9jYXRvcnMgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IENvbnRleHRNZW51IH0gZnJvbSAnLi4vbWVudS9Db250ZXh0TWVudS5qcydcbmltcG9ydCB7IEVkaXRvclZpZXcsIEVkaXRvckdyb3VwIH0gZnJvbSAnLi4vaW5kZXguanMnXG5cbmltcG9ydCB7XG4gICAgUGFnZURlY29yYXRvciwgSVBhZ2VEZWNvcmF0b3IsIEJhc2VQYWdlLCBWU0NvZGVMb2NhdG9yTWFwLCBzbGVlcFxufSBmcm9tICcuLi91dGlscy5qcydcbmltcG9ydCB7IFNldHRpbmdzRWRpdG9yIGFzIFNldHRpbmdzRWRpdG9yTG9jYXRvcnMgfSBmcm9tICcuLi8uLi9sb2NhdG9ycy8xLjczLjAuanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0dGluZ3NFZGl0b3IgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjxFZGl0b3JMb2NhdG9ycz4ge31cbi8qKlxuICogUGFnZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnRlcm5hbCBWU0NvZGUgc2V0dGluZ3MgZWRpdG9yXG4gKlxuICogQGNhdGVnb3J5IEVkaXRvclxuICovXG5AUGFnZURlY29yYXRvcihTZXR0aW5nc0VkaXRvckxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFNldHRpbmdzRWRpdG9yIGV4dGVuZHMgRWRpdG9yPEVkaXRvckxvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTZXR0aW5nc0VkaXRvcicgYXMgY29uc3RcbiAgICBwdWJsaWMgdmlldzogRWRpdG9yVmlldyB8IEVkaXRvckdyb3VwXG5cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLFxuICAgICAgICB2aWV3PzogRWRpdG9yVmlldyB8IEVkaXRvckdyb3VwXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCB2aWV3Py5lbGVtKVxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3IHx8IG5ldyBFZGl0b3JWaWV3KHRoaXMubG9jYXRvck1hcClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIGEgc2V0dGluZyB3aXRoIGEgcGFydGljdWxhciB0aXRsZSBhbmQgY2F0ZWdvcnkuXG4gICAgICogUmV0dXJucyBhbiBhcHByb3ByaWF0ZSBTZXR0aW5nIG9iamVjdCBpZiB0aGUgbGFiZWwgaXMgZm91bmQsXG4gICAgICogdW5kZWZpbmVkIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIElmIHlvdXIgc2V0dGluZyBoYXMgbmVzdGVkIGNhdGVnb3JpZXMgKGkuZSBgZXhhbXBsZS5nZW5lcmFsLnRlc3RgKSxcbiAgICAgKiBwYXNzIGluIGVhY2ggY2F0ZWdvcnkgYXMgYSBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIHNldHRpbmdcbiAgICAgKiBAcGFyYW0gY2F0ZWdvcmllcyBjYXRlZ29yeSBvZiB0aGUgc2V0dGluZ1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgU2V0dGluZyBvYmplY3QgaWYgZm91bmQsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBmaW5kU2V0dGluZyAodGl0bGU6IHN0cmluZywgLi4uY2F0ZWdvcmllczogc3RyaW5nW10pOiBQcm9taXNlPFNldHRpbmc+IHtcbiAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBjYXRlZ29yaWVzLmpvaW4oJyDigLogJylcbiAgICAgICAgY29uc3Qgc2VhcmNoQm94ID0gYXdhaXQgdGhpcy5lbGVtLiQodGhpcy5sb2NhdG9yTWFwLkVkaXRvci5pbnB1dEFyZWEgYXMgc3RyaW5nKVxuICAgICAgICBhd2FpdCBzZWFyY2hCb3guc2V0VmFsdWUoYCR7Y2F0ZWdvcnl9OiAke3RpdGxlfWApXG5cbiAgICAgICAgY29uc3QgY291bnQgPSBhd2FpdCB0aGlzLml0ZW1Db3VudCRcbiAgICAgICAgbGV0IHRleHRDb3VudCA9IGF3YWl0IGNvdW50LmdldFRleHQoKVxuXG4gICAgICAgIGF3YWl0IGJyb3dzZXIud2FpdFVudGlsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKDE1MDApXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgY291bnQuZ2V0VGV4dCgpXG4gICAgICAgICAgICBpZiAodGV4dCAhPT0gdGV4dENvdW50KSB7XG4gICAgICAgICAgICAgICAgdGV4dENvdW50ID0gdGV4dFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSlcblxuICAgICAgICBsZXQgc2V0dGluZyE6IFNldHRpbmdcbiAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLml0ZW1Sb3ckJFxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IChhd2FpdCB0aGlzLmNyZWF0ZVNldHRpbmcoaXRlbSwgdGl0bGUsIGNhdGVnb3J5KSkud2FpdCgpXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0dGluZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3aXRjaCBiZXR3ZWVuIHNldHRpbmdzIHBlcnNwZWN0aXZlc1xuICAgICAqIFdvcmtzIG9ubHkgaWYgeW91ciB2c2NvZGUgaW5zdGFuY2UgaGFzIGJvdGggdXNlciBhbmQgd29ya3NwYWNlIHNldHRpbmdzIGF2YWlsYWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHBlcnNwZWN0aXZlIFVzZXIgb3IgV29ya3NwYWNlXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGFwcHJvcHJpYXRlIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAgICovXG4gICAgYXN5bmMgc3dpdGNoVG9QZXJzcGVjdGl2ZSAocGVyc3BlY3RpdmU6ICdVc2VyJyB8ICdXb3Jrc3BhY2UnKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuaGVhZGVyJFxuICAgICAgICAgICAgLiQodGhpcy5sb2NhdG9ycy50YWJzKVxuICAgICAgICAgICAgLiQodGhpcy5sb2NhdG9ycy5hY3Rpb25zKVxuICAgICAgICAgICAgLiQodGhpcy5sb2NhdG9ycy5hY3Rpb24ocGVyc3BlY3RpdmUpKVxuICAgICAgICAgICAgLmNsaWNrKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb250ZXh0IG1lbnUgaXMgZGlzYWJsZWQgaW4gdGhpcyBlZGl0b3IsIHRocm93IGFuIGVycm9yXG4gICAgICovXG4gICAgb3BlbkNvbnRleHRNZW51ICgpOiBQcm9taXNlPENvbnRleHRNZW51PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWQnKVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgY3JlYXRlU2V0dGluZyAoZWxlbWVudDogV2ViZHJpdmVySU8uRWxlbWVudCwgdGl0bGU6IHN0cmluZywgY2F0ZWdvcnk6IHN0cmluZyk6IFByb21pc2U8U2V0dGluZz4ge1xuICAgICAgICBpZiAoIWF3YWl0IGVsZW1lbnQuJCh0aGlzLmxvY2F0b3JzLnNldHRpbmdDb25zdHJ1Y3Rvcih0aXRsZSwgY2F0ZWdvcnkpKS5pc0V4aXN0aW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2V0dGluZyBub3QgZm91bmQnKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IGEgY29tYm8gc2V0dGluZ1xuICAgICAgICBpZiAoYXdhaXQgZWxlbWVudC4kKHRoaXMubG9jYXRvcnMuY29tYm9TZXR0aW5nKS5pc0V4aXN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tYm9TZXR0aW5nKHRoaXMubG9jYXRvck1hcCwgdGl0bGUsIGNhdGVnb3J5LCB0aGlzKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRleHQgc2V0dGluZ1xuICAgICAgICBpZiAoYXdhaXQgZWxlbWVudC4kKHRoaXMubG9jYXRvcnMudGV4dFNldHRpbmcpLmlzRXhpc3RpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0U2V0dGluZyh0aGlzLmxvY2F0b3JNYXAsIHRpdGxlLCBjYXRlZ29yeSwgdGhpcylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSBjaGVja2JveCBzZXR0aW5nXG4gICAgICAgIGlmIChhd2FpdCBlbGVtZW50LiQodGhpcy5sb2NhdG9ycy5jaGVja2JveFNldHRpbmcpLmlzRXhpc3RpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja2JveFNldHRpbmcodGhpcy5sb2NhdG9yTWFwLCB0aXRsZSwgY2F0ZWdvcnksIHRoaXMpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgbGluayBzZXR0aW5nXG4gICAgICAgIGlmIChhd2FpdCBlbGVtZW50LiQodGhpcy5sb2NhdG9ycy5saW5rQnV0dG9uKS5pc0V4aXN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlua1NldHRpbmcodGhpcy5sb2NhdG9yTWFwLCB0aXRsZSwgY2F0ZWdvcnksIHRoaXMpXG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldHRpbmcgdHlwZSBub3Qgc3VwcG9ydGVkJylcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0dGluZyBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBTZXR0aW5nc0VkaXRvckxvY2F0b3JzPiB7fVxuLyoqXG4gKiBBYnN0cmFjdCBpdGVtIHJlcHJlc2VudGluZyBhIFNldHRpbmcgd2l0aCB0aXRsZSwgZGVzY3JpcHRpb24gYW5kXG4gKiBhbiBpbnB1dCBlbGVtZW50IChjb21iby90ZXh0Ym94L2NoZWNrYm94L2xpbmspXG4gKlxuICogQGNhdGVnb3J5IEVkaXRvclxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2V0dGluZyBleHRlbmRzIEJhc2VQYWdlPHR5cGVvZiBTZXR0aW5nc0VkaXRvckxvY2F0b3JzPiB7XG4gICAgcHJpdmF0ZSB0aXRsZTogc3RyaW5nXG4gICAgcHJpdmF0ZSBjYXRlZ29yeTogc3RyaW5nXG5cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLFxuICAgICAgICB0aXRsZTogc3RyaW5nLFxuICAgICAgICBjYXRlZ29yeTogc3RyaW5nLFxuICAgICAgICBwdWJsaWMgc2V0dGluZ3M6IFNldHRpbmdzRWRpdG9yXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCAobG9jYXRvcnMuU2V0dGluZ3NFZGl0b3Iuc2V0dGluZ0NvbnN0cnVjdG9yIGFzIEZ1bmN0aW9uKSh0aXRsZSwgY2F0ZWdvcnkpIGFzIHN0cmluZylcbiAgICAgICAgdGhpcy50aXRsZSA9IHRpdGxlXG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBjYXRlZ29yeVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIHNldHRpbmcgYmFzZWQgb24gaXRzIGlucHV0IHR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc2V0dGluZ1xuICAgICAqL1xuICAgIGFic3RyYWN0IGdldFZhbHVlICgpOiBQcm9taXNlPHN0cmluZyB8IGJvb2xlYW4+XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBzZXR0aW5nIGJhc2VkIG9uIGl0cyBpbnB1dCB0eXBlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgYm9vbGVhbiBmb3IgY2hlY2tib3hlcywgc3RyaW5nIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFic3RyYWN0IHNldFZhbHVlICh2YWx1ZTogc3RyaW5nIHwgYm9vbGVhbik6IFByb21pc2U8dm9pZD5cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2F0ZWdvcnkgb2YgdGhlIHNldHRpbmdcbiAgICAgKiBBbGwgc2V0dGluZ3MgYXJlIGxhYmVsZWQgYXMgQ2F0ZWdvcnk6IFRpdGxlXG4gICAgICovXG4gICAgZ2V0Q2F0ZWdvcnkgKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhdGVnb3J5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGRlc2NyaXB0aW9uIG9mIHRoZSBzZXR0aW5nXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc2V0dGluZyBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGdldERlc2NyaXB0aW9uICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nRGVzY3RpcHRpb24kLmdldFRleHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aXRsZSBvZiB0aGUgc2V0dGluZ1xuICAgICAqL1xuICAgIGdldFRpdGxlICgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50aXRsZVxuICAgIH1cbn1cblxuLyoqXG4gKiBTZXR0aW5nIHdpdGggYSBjb21ibyBib3hcbiAqXG4gKiBAY2F0ZWdvcnkgRWRpdG9yXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFNldHRpbmdzRWRpdG9yTG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgQ29tYm9TZXR0aW5nIGV4dGVuZHMgU2V0dGluZyB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTZXR0aW5nc0VkaXRvcicgYXMgY29uc3RcblxuICAgIGdldFZhbHVlICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21ib1NldHRpbmckLmdldEF0dHJpYnV0ZSgndGl0bGUnKVxuICAgIH1cblxuICAgIGFzeW5jIHNldFZhbHVlICh2YWx1ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBhd2FpdCB0aGlzLmdldE9wdGlvbnMoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICgoYXdhaXQgcm93c1tpXS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpLmluZGV4T2YoJ2Rpc2FibGVkJykgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJvd3NbaV0uJCh0aGlzLmxvY2F0b3JzLmNvbWJvT3B0aW9uKS5nZXRUZXh0KClcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcm93c1tpXS5jbGljaygpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGFiZWxzIG9mIGFsbCBvcHRpb25zIGZyb20gdGhlIGNvbWJvXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXJyYXkgb2Ygc3RyaW5nIHZhbHVlc1xuICAgICAqL1xuICAgIGFzeW5jIGdldFZhbHVlcyAoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXVxuICAgICAgICBjb25zdCByb3dzID0gYXdhaXQgdGhpcy5nZXRPcHRpb25zKClcblxuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChhd2FpdCByb3cuJCh0aGlzLmxvY2F0b3JzLmNvbWJvT3B0aW9uKS5nZXRUZXh0KCkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlc1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZ2V0T3B0aW9ucyAoKSB7XG4gICAgICAgIGNvbnN0IG1lbnUgPSBhd2FpdCB0aGlzLm9wZW5Db21ibygpXG4gICAgICAgIHJldHVybiBtZW51LiQkKHRoaXMubG9jYXRvcnMuaXRlbVJvdylcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIG9wZW5Db21ibyAoKSB7XG4gICAgICAgIGNvbnN0IGNvbWJvID0gYXdhaXQgdGhpcy5jb21ib1NldHRpbmckXG4gICAgICAgIGNvbnN0IHdvcmtiZW5jaCA9IGF3YWl0IGJyb3dzZXIuJCh0aGlzLmxvY2F0b3JNYXAuV29ya2JlbmNoLmVsZW0gYXMgc3RyaW5nKVxuICAgICAgICBjb25zdCBtZW51cyA9IGF3YWl0IHdvcmtiZW5jaC4kJCh0aGlzLmxvY2F0b3JNYXAuQ29udGV4dE1lbnUuY29udGV4dFZpZXcgYXMgc3RyaW5nKVxuICAgICAgICBsZXQgbWVudSE6IFdlYmRyaXZlcklPLkVsZW1lbnRcblxuICAgICAgICBpZiAobWVudXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgYXdhaXQgY29tYm8uY2xpY2soKVxuICAgICAgICAgICAgbWVudSA9IGF3YWl0IHdvcmtiZW5jaC4kKHRoaXMubG9jYXRvck1hcC5Db250ZXh0TWVudS5jb250ZXh0VmlldyBhcyBzdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gbWVudVxuICAgICAgICB9XG4gICAgICAgIGlmIChhd2FpdCBtZW51c1swXS5pc0Rpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICBhd2FpdCBjb21iby5jbGljaygpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgd2Rpby9uby1wYXVzZVxuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci5wYXVzZSgyMDApXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgY29tYm8uY2xpY2soKVxuICAgICAgICBtZW51ID0gYXdhaXQgd29ya2JlbmNoLiQodGhpcy5sb2NhdG9yTWFwLkNvbnRleHRNZW51LmNvbnRleHRWaWV3IGFzIHN0cmluZylcbiAgICAgICAgcmV0dXJuIG1lbnVcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dFNldHRpbmcgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgU2V0dGluZ3NFZGl0b3JMb2NhdG9ycz4ge31cbi8qKlxuICogU2V0dGluZyB3aXRoIGEgdGV4dCBib3ggaW5wdXRcbiAqXG4gKiBAY2F0ZWdvcnkgRWRpdG9yXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFNldHRpbmdzRWRpdG9yTG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgVGV4dFNldHRpbmcgZXh0ZW5kcyBTZXR0aW5nIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1NldHRpbmdzRWRpdG9yJyBhcyBjb25zdFxuXG4gICAgYXN5bmMgZ2V0VmFsdWUgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRTZXR0aW5nJC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcbiAgICB9XG5cbiAgICBhc3luYyBzZXRWYWx1ZSAodmFsdWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGF3YWl0IHRoaXMudGV4dFNldHRpbmckXG4gICAgICAgIGF3YWl0IGlucHV0LnNldFZhbHVlKHZhbHVlKVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZXh0U2V0dGluZyBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBTZXR0aW5nc0VkaXRvckxvY2F0b3JzPiB7fVxuLyoqXG4gKiBTZXR0aW5nIHdpdGggYSBjaGVja2JveFxuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoU2V0dGluZ3NFZGl0b3JMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBDaGVja2JveFNldHRpbmcgZXh0ZW5kcyBTZXR0aW5nIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1NldHRpbmdzRWRpdG9yJyBhcyBjb25zdFxuXG4gICAgYXN5bmMgZ2V0VmFsdWUgKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gYXdhaXQgdGhpcy5jaGVja2JveFNldHRpbmckLmdldEF0dHJpYnV0ZSh0aGlzLmxvY2F0b3JzLmNoZWNrYm94Q2hlY2tlZClcbiAgICAgICAgaWYgKGNoZWNrZWQgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBhc3luYyBzZXRWYWx1ZSAodmFsdWU6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuZ2V0VmFsdWUoKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2hlY2tib3hTZXR0aW5nJC5jbGljaygpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua1NldHRpbmcgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgU2V0dGluZ3NFZGl0b3JMb2NhdG9ycz4ge31cbi8qKlxuICogU2V0dGluZyB3aXRoIG5vIHZhbHVlLCB3aXRoIGEgbGluayB0byBzZXR0aW5ncy5qc29uIGluc3RlYWRcbiAqXG4gKiBAY2F0ZWdvcnkgRWRpdG9yXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFNldHRpbmdzRWRpdG9yTG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgTGlua1NldHRpbmcgZXh0ZW5kcyBTZXR0aW5nIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1NldHRpbmdzRWRpdG9yJyBhcyBjb25zdFxuXG4gICAgZ2V0VmFsdWUgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIGdldFZhbHVlIGlzIG5vdCBhdmFpbGFibGUgZm9yIExpbmtTZXR0aW5nJylcbiAgICB9XG5cbiAgICBzZXRWYWx1ZSAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIHNldFZhbHVlIGlzIG5vdCBhdmFpbGFibGUgZm9yIExpbmtTZXR0aW5nJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBsaW5rIHRoYXQgbGVhZHMgdG8gdGhlIHZhbHVlIGluIHNldHRpbmdzLmpzb25cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBsaW5rIGhhcyBiZWVuIGNsaWNrZWRcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuTGluayAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMubGlua0J1dHRvbiQuY2xpY2soKVxuICAgIH1cbn1cbiJdfQ==