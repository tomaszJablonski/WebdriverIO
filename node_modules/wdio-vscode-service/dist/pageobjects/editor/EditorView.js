var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { TextEditor, DiffEditor, SettingsEditor } from '../index.js';
import { PageDecorator, BasePage, ElementWithContextMenu } from '../utils.js';
import { EditorView as EditorViewLocators, Editor as EditorLocatorsObj } from '../../locators/1.73.0.js';
/**
 * View handling the open editors
 *
 * @category Editor
 */
let EditorView = class EditorView extends BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'EditorView';
    }
    /**
     * Switch to an editor tab with the given title
     * @param title title of the tab
     * @param groupIndex zero based index for the editor group (0 for the left most group)
     * @returns Promise resolving to Editor object
     */
    async openEditor(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.openEditor(title);
    }
    /**
     * Close an editor tab with the given title
     * @param title title of the tab
     * @param groupIndex zero based index for the editor group (0 for the left most group)
     * @returns Promise resolving when the tab's close button is pressed
     */
    async closeEditor(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.closeEditor(title);
    }
    /**
     * Close all open editor tabs
     * @param groupIndex optional index to specify an editor group
     * @returns Promise resolving once all tabs have had their close button pressed
     */
    async closeAllEditors(groupIndex) {
        let groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            await groups[0].closeAllEditors();
            return;
        }
        while (groups.length > 0 && (await groups[0].getOpenEditorTitles()).length > 0) {
            await groups[0].closeAllEditors();
            groups = await this.getEditorGroups();
        }
    }
    /**
     * Retrieve all open editor tab titles in an array
     * @param groupIndex optional index to specify an editor group, if left empty will search all groups
     * @returns Promise resolving to array of editor titles
     */
    async getOpenEditorTitles(groupIndex) {
        const groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            return groups[groupIndex].getOpenEditorTitles();
        }
        const titles = [];
        for (const group of groups) {
            titles.push(...(await group.getOpenEditorTitles()));
        }
        return titles;
    }
    /**
     * Retrieve an editor tab from a given group by title
     * @param title title of the tab
     * @param groupIndex zero based index of the editor group, default 0 (leftmost one)
     * @returns promise resolving to EditorTab object
     */
    async getTabByTitle(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getTabByTitle(title);
    }
    /**
     * Retrieve all open editor tabs
     * @param groupIndex index of group to search for tabs, if left undefined, all groups are searched
     * @returns promise resolving to EditorTab list
     */
    async getOpenTabs(groupIndex) {
        const groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            return groups[groupIndex].getOpenTabs();
        }
        const tabs = [];
        for (const group of groups) {
            tabs.push(...(await group.getOpenTabs()));
        }
        return tabs;
    }
    /**
     * Retrieve the active editor tab
     * @returns promise resolving to EditorTab object, undefined if no tab is active
     */
    async getActiveTab() {
        const tabs = await this.getOpenTabs();
        const klasses = await Promise.all(tabs.map(async (tab) => tab.elem.getAttribute('class')));
        const index = klasses.findIndex((klass) => klass.indexOf('active') > -1);
        if (index > -1) {
            return tabs[index];
        }
        return undefined;
    }
    /**
     * Retrieve all editor groups in a list, sorted left to right
     * @returns promise resolving to an array of EditorGroup objects
     */
    async getEditorGroups() {
        const groups = [];
        for await (const elements of this.editorGroup$$) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            groups.push(await (new EditorGroup(this.locatorMap, elements, this).poll()));
        }
        // sort the groups by x coordinates, so the leftmost is always at index 0
        for (let i = 0; i < groups.length - 1; i += 1) {
            for (let j = 0; j < groups.length - i - 1; j += 1) {
                if ((await groups[j].elem.getLocation('x')) > (await groups[j + 1].elem.getLocation('x'))) {
                    const temp = groups[j];
                    groups[j] = groups[j + 1];
                    groups[j + 1] = temp;
                }
            }
        }
        return groups;
    }
    /**
     * Retrieve an editor group with a given index (counting from left to right)
     * @param index zero based index of the editor group (leftmost group has index 0)
     * @returns promise resolving to an EditorGroup object
     */
    async getEditorGroup(index) {
        return (await this.getEditorGroups())[index];
    }
    /**
     * Get editor actions of a select editor group
     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0
     * @returns promise resolving to list of WebElement objects
     */
    async getActions(groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getActions();
    }
    /**
     * Get editor action of a select editor group, search by title
     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0
     * @returns promise resolving to WebElement object if found, undefined otherwise
     */
    async getAction(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getAction(title);
    }
};
EditorView = __decorate([
    PageDecorator(EditorViewLocators)
], EditorView);
export { EditorView };
/**
 * Page object representing an editor group
 *
 * @category Editor
 */
let EditorGroup = class EditorGroup extends BasePage {
    constructor(locators, element, view = new EditorView(locators)) {
        super(locators, element);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'EditorView';
    }
    /**
     * Switch to an editor tab with the given title
     * @param title title of the tab
     * @returns Promise resolving to Editor object
     */
    async openEditor(title) {
        const tab = await this.getTabByTitle(title);
        await tab.select();
        if (await this.settingsEditor$.isExisting()) {
            return new SettingsEditor(this.locatorMap, this).wait();
        }
        if (await this.diffEditor$.isExisting()) {
            return new DiffEditor(this.locatorMap, this.locatorMap.Editor.elem, this).wait();
        }
        return new TextEditor(this.locatorMap, this.locatorMap.Editor.elem, this).wait();
    }
    /**
     * Close an editor tab with the given title
     * @param title title of the tab
     * @returns Promise resolving when the tab's close button is pressed
     */
    async closeEditor(title) {
        const tab = await this.getTabByTitle(title);
        await tab.elem.moveTo();
        const closeButton = await tab.elem.$(this.locators.closeTab);
        await closeButton.click();
    }
    /**
     * Close all open editor tabs
     * @returns Promise resolving once all tabs have had their close button pressed
     */
    async closeAllEditors() {
        let titles = await this.getOpenEditorTitles();
        while (titles.length > 0) {
            await this.closeEditor(titles[0]);
            try {
                // check if the group still exists
                await this.elem.getTagName();
            }
            catch (err) {
                break;
            }
            titles = await this.getOpenEditorTitles();
        }
    }
    /**
     * Retrieve all open editor tab titles in an array
     * @returns Promise resolving to array of editor titles
     */
    async getOpenEditorTitles() {
        const tabs = await this.tab$$;
        const titles = [];
        for (const tab of tabs) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const title = await new EditorTab(this.locatorMap, tab, this.view).getTitle();
            titles.push(title);
        }
        return titles;
    }
    /**
     * Retrieve an editor tab by title
     * @param title title of the tab
     * @returns promise resolving to EditorTab object
     */
    async getTabByTitle(title) {
        const tabs = await this.tab$$;
        const availableLabels = new Set();
        for (const tab of tabs) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const editorTab = new EditorTab(this.locatorMap, tab, this.view);
            const label = await editorTab.getTitle();
            availableLabels.add(label);
            if (label === title) {
                return editorTab;
            }
        }
        throw new Error(`No editor with title '${title}' found, `
            + `available editor were: ${[...availableLabels].join(', ')}`);
    }
    /**
     * Retrieve all open editor tabs
     * @returns promise resolving to EditorTab list
     */
    async getOpenTabs() {
        const tabs = this.tab$$;
        return tabs.map(async (tab) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        new EditorTab(this.locatorMap, tab, this.view).wait()));
    }
    /**
     * Retrieve the active editor tab
     * @returns promise resolving to EditorTab object, undefined if no tab is active
     */
    async getActiveTab() {
        const tabs = await this.getOpenTabs();
        const klasses = await Promise.all(tabs.map(async (tab) => tab.elem.getAttribute('class')));
        const index = klasses.findIndex((klass) => klass.indexOf('active') > -1);
        if (index > -1) {
            return tabs[index];
        }
        return undefined;
    }
    /**
     * Retrieve the editor action buttons as WebElements
     * @returns promise resolving to list of WebElement objects
     */
    async getActions() {
        return this.actionContainer$.$$(this.locators.actionItem);
    }
    /**
     * Find an editor action button by title
     * @param title title of the button
     * @returns promise resolving to WebElement representing the button if found, undefined otherwise
     */
    async getAction(title) {
        const actions = await this.getActions();
        for (const item of actions) {
            if (await item.getAttribute('title') === title) {
                return item;
            }
        }
        return undefined;
    }
};
EditorGroup = __decorate([
    PageDecorator(EditorViewLocators)
], EditorGroup);
export { EditorGroup };
/**
 * Page object for editor view tab
 *
 * @category Editor
 */
let EditorTab = class EditorTab extends ElementWithContextMenu {
    constructor(locators, element, view) {
        super(locators, element);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'Editor';
    }
    /**
     * Get the tab title as string
     */
    async getTitle() {
        return this.title$.getText();
    }
    /**
     * Select (click) the tab
     */
    async select() {
        await this.elem.click();
    }
};
EditorTab = __decorate([
    PageDecorator(EditorLocatorsObj)
], EditorTab);
export { EditorTab };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRpdG9yVmlldy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wYWdlb2JqZWN0cy9lZGl0b3IvRWRpdG9yVmlldy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsTUFBTSxhQUFhLENBQUE7QUFDcEUsT0FBTyxFQUNILGFBQWEsRUFBa0IsUUFBUSxFQUFFLHNCQUFzQixFQUNsRSxNQUFNLGFBQWEsQ0FBQTtBQUNwQixPQUFPLEVBQ0gsVUFBVSxJQUFJLGtCQUFrQixFQUNoQyxNQUFNLElBQUksaUJBQWlCLEVBQzlCLE1BQU0sMEJBQTBCLENBQUE7QUFHakM7Ozs7R0FJRztBQUVJLElBQU0sVUFBVSxHQUFoQixNQUFNLFVBQVcsU0FBUSxRQUFtQztJQUE1RDs7UUFDSDs7V0FFRztRQUNJLGVBQVUsR0FBRyxZQUFxQixDQUFBO0lBMEo3QyxDQUFDO0lBeEpHOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLFVBQVUsQ0FBRSxLQUFhLEVBQUUsVUFBVSxHQUFHLENBQUM7UUFDM0MsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFBO1FBQ25ELE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUNsQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsV0FBVyxDQUFFLEtBQWEsRUFBRSxVQUFVLEdBQUcsQ0FBQztRQUM1QyxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUE7UUFDbkQsT0FBTyxLQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQ25DLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FBRSxVQUFtQjtRQUN0QyxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FB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QUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFBO0lBQzNCLENBQUM7Q0FDSixDQUFBO0FBM0JZLFNBQVM7SUFEckIsYUFBYSxDQUFDLGlCQUFpQixDQUFDO0dBQ3BCLFNBQVMsQ0EyQnJCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDaGFpbmFibGVQcm9taXNlRWxlbWVudCB9IGZyb20gJ3dlYmRyaXZlcmlvJ1xuXG5pbXBvcnQgeyBUZXh0RWRpdG9yLCBEaWZmRWRpdG9yLCBTZXR0aW5nc0VkaXRvciB9IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgICBQYWdlRGVjb3JhdG9yLCBJUGFnZURlY29yYXRvciwgQmFzZVBhZ2UsIEVsZW1lbnRXaXRoQ29udGV4dE1lbnUsIFZTQ29kZUxvY2F0b3JNYXBcbn0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQge1xuICAgIEVkaXRvclZpZXcgYXMgRWRpdG9yVmlld0xvY2F0b3JzLFxuICAgIEVkaXRvciBhcyBFZGl0b3JMb2NhdG9yc09ialxufSBmcm9tICcuLi8uLi9sb2NhdG9ycy8xLjczLjAuanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRWRpdG9yVmlldyBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBFZGl0b3JWaWV3TG9jYXRvcnM+IHt9XG4vKipcbiAqIFZpZXcgaGFuZGxpbmcgdGhlIG9wZW4gZWRpdG9yc1xuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoRWRpdG9yVmlld0xvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIEVkaXRvclZpZXcgZXh0ZW5kcyBCYXNlUGFnZTx0eXBlb2YgRWRpdG9yVmlld0xvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdFZGl0b3JWaWV3JyBhcyBjb25zdFxuXG4gICAgLyoqXG4gICAgICogU3dpdGNoIHRvIGFuIGVkaXRvciB0YWIgd2l0aCB0aGUgZ2l2ZW4gdGl0bGVcbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIHRhYlxuICAgICAqIEBwYXJhbSBncm91cEluZGV4IHplcm8gYmFzZWQgaW5kZXggZm9yIHRoZSBlZGl0b3IgZ3JvdXAgKDAgZm9yIHRoZSBsZWZ0IG1vc3QgZ3JvdXApXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIG9wZW5FZGl0b3IgKHRpdGxlOiBzdHJpbmcsIGdyb3VwSW5kZXggPSAwKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cChncm91cEluZGV4KVxuICAgICAgICByZXR1cm4gZ3JvdXAub3BlbkVkaXRvcih0aXRsZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbiBlZGl0b3IgdGFiIHdpdGggdGhlIGdpdmVuIHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSB0YWJcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCB6ZXJvIGJhc2VkIGluZGV4IGZvciB0aGUgZWRpdG9yIGdyb3VwICgwIGZvciB0aGUgbGVmdCBtb3N0IGdyb3VwKVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIHRhYidzIGNsb3NlIGJ1dHRvbiBpcyBwcmVzc2VkXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2VFZGl0b3IgKHRpdGxlOiBzdHJpbmcsIGdyb3VwSW5kZXggPSAwKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cChncm91cEluZGV4KVxuICAgICAgICByZXR1cm4gZ3JvdXAuY2xvc2VFZGl0b3IodGl0bGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgYWxsIG9wZW4gZWRpdG9yIHRhYnNcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCBvcHRpb25hbCBpbmRleCB0byBzcGVjaWZ5IGFuIGVkaXRvciBncm91cFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIG9uY2UgYWxsIHRhYnMgaGF2ZSBoYWQgdGhlaXIgY2xvc2UgYnV0dG9uIHByZXNzZWRcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZUFsbEVkaXRvcnMgKGdyb3VwSW5kZXg/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgbGV0IGdyb3VwcyA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXBzKClcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgZ3JvdXBzWzBdLmNsb3NlQWxsRWRpdG9ycygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChncm91cHMubGVuZ3RoID4gMCAmJiAoYXdhaXQgZ3JvdXBzWzBdLmdldE9wZW5FZGl0b3JUaXRsZXMoKSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgZ3JvdXBzWzBdLmNsb3NlQWxsRWRpdG9ycygpXG4gICAgICAgICAgICBncm91cHMgPSBhd2FpdCB0aGlzLmdldEVkaXRvckdyb3VwcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgb3BlbiBlZGl0b3IgdGFiIHRpdGxlcyBpbiBhbiBhcnJheVxuICAgICAqIEBwYXJhbSBncm91cEluZGV4IG9wdGlvbmFsIGluZGV4IHRvIHNwZWNpZnkgYW4gZWRpdG9yIGdyb3VwLCBpZiBsZWZ0IGVtcHR5IHdpbGwgc2VhcmNoIGFsbCBncm91cHNcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBlZGl0b3IgdGl0bGVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0T3BlbkVkaXRvclRpdGxlcyAoZ3JvdXBJbmRleD86IG51bWJlcik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cHMoKVxuICAgICAgICBpZiAoZ3JvdXBJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBzW2dyb3VwSW5kZXhdLmdldE9wZW5FZGl0b3JUaXRsZXMoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpdGxlczogc3RyaW5nW10gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGdyb3Vwcykge1xuICAgICAgICAgICAgdGl0bGVzLnB1c2goLi4uKGF3YWl0IGdyb3VwLmdldE9wZW5FZGl0b3JUaXRsZXMoKSkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpdGxlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFuIGVkaXRvciB0YWIgZnJvbSBhIGdpdmVuIGdyb3VwIGJ5IHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSB0YWJcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCB6ZXJvIGJhc2VkIGluZGV4IG9mIHRoZSBlZGl0b3IgZ3JvdXAsIGRlZmF1bHQgMCAobGVmdG1vc3Qgb25lKVxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIEVkaXRvclRhYiBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUYWJCeVRpdGxlICh0aXRsZTogc3RyaW5nLCBncm91cEluZGV4ID0gMCk6IFByb21pc2U8RWRpdG9yVGFiPiB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cChncm91cEluZGV4KVxuICAgICAgICByZXR1cm4gZ3JvdXAuZ2V0VGFiQnlUaXRsZSh0aXRsZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgb3BlbiBlZGl0b3IgdGFic1xuICAgICAqIEBwYXJhbSBncm91cEluZGV4IGluZGV4IG9mIGdyb3VwIHRvIHNlYXJjaCBmb3IgdGFicywgaWYgbGVmdCB1bmRlZmluZWQsIGFsbCBncm91cHMgYXJlIHNlYXJjaGVkXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yVGFiIGxpc3RcbiAgICAgKi9cbiAgICBhc3luYyBnZXRPcGVuVGFicyAoZ3JvdXBJbmRleD86IG51bWJlcik6IFByb21pc2U8RWRpdG9yVGFiW10+IHtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cHMoKVxuICAgICAgICBpZiAoZ3JvdXBJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBzW2dyb3VwSW5kZXhdLmdldE9wZW5UYWJzKClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJzOiBFZGl0b3JUYWJbXSA9IFtdXG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZ3JvdXBzKSB7XG4gICAgICAgICAgICB0YWJzLnB1c2goLi4uKGF3YWl0IGdyb3VwLmdldE9wZW5UYWJzKCkpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGFjdGl2ZSBlZGl0b3IgdGFiXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yVGFiIG9iamVjdCwgdW5kZWZpbmVkIGlmIG5vIHRhYiBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3RpdmVUYWIgKCk6IFByb21pc2U8RWRpdG9yVGFiIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHRhYnMgPSBhd2FpdCB0aGlzLmdldE9wZW5UYWJzKClcbiAgICAgICAgY29uc3Qga2xhc3NlcyA9IGF3YWl0IFByb21pc2UuYWxsKHRhYnMubWFwKGFzeW5jICh0YWIpID0+IHRhYi5lbGVtLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkpXG4gICAgICAgIGNvbnN0IGluZGV4ID0ga2xhc3Nlcy5maW5kSW5kZXgoKGtsYXNzKSA9PiBrbGFzcy5pbmRleE9mKCdhY3RpdmUnKSA+IC0xKVxuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFic1tpbmRleF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYWxsIGVkaXRvciBncm91cHMgaW4gYSBsaXN0LCBzb3J0ZWQgbGVmdCB0byByaWdodFxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIEVkaXRvckdyb3VwIG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRFZGl0b3JHcm91cHMgKCk6IFByb21pc2U8RWRpdG9yR3JvdXBbXT4ge1xuICAgICAgICBjb25zdCBncm91cHM6IEVkaXRvckdyb3VwW10gPSBbXVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW1lbnRzIG9mIHRoaXMuZWRpdG9yR3JvdXAkJCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGF3YWl0IChuZXcgRWRpdG9yR3JvdXAodGhpcy5sb2NhdG9yTWFwLCBlbGVtZW50cyBhcyBhbnksIHRoaXMpLnBvbGwoKSkpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzb3J0IHRoZSBncm91cHMgYnkgeCBjb29yZGluYXRlcywgc28gdGhlIGxlZnRtb3N0IGlzIGFsd2F5cyBhdCBpbmRleCAwXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncm91cHMubGVuZ3RoIC0gaSAtIDE7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgZ3JvdXBzW2pdLmVsZW0uZ2V0TG9jYXRpb24oJ3gnKSkgPiAoYXdhaXQgZ3JvdXBzW2ogKyAxXS5lbGVtLmdldExvY2F0aW9uKCd4JykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBncm91cHNbal1cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW2pdID0gZ3JvdXBzW2ogKyAxXVxuICAgICAgICAgICAgICAgICAgICBncm91cHNbaiArIDFdID0gdGVtcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXBzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYW4gZWRpdG9yIGdyb3VwIHdpdGggYSBnaXZlbiBpbmRleCAoY291bnRpbmcgZnJvbSBsZWZ0IHRvIHJpZ2h0KVxuICAgICAqIEBwYXJhbSBpbmRleCB6ZXJvIGJhc2VkIGluZGV4IG9mIHRoZSBlZGl0b3IgZ3JvdXAgKGxlZnRtb3N0IGdyb3VwIGhhcyBpbmRleCAwKVxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIGFuIEVkaXRvckdyb3VwIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIGdldEVkaXRvckdyb3VwIChpbmRleDogbnVtYmVyKTogUHJvbWlzZTxFZGl0b3JHcm91cD4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXBzKCkpW2luZGV4XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBlZGl0b3IgYWN0aW9ucyBvZiBhIHNlbGVjdCBlZGl0b3IgZ3JvdXBcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCB6ZXJvIGJhc2VkIGluZGV4IG9mIHRoZSBlZGl0b3IgZ3JvdXAgKGxlZnRtb3N0IGdyb3VwIGhhcyBpbmRleCAwKSwgZGVmYXVsdCAwXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gbGlzdCBvZiBXZWJFbGVtZW50IG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3Rpb25zIChncm91cEluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCBncm91cCA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXAoZ3JvdXBJbmRleClcbiAgICAgICAgcmV0dXJuIGdyb3VwLmdldEFjdGlvbnMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBlZGl0b3IgYWN0aW9uIG9mIGEgc2VsZWN0IGVkaXRvciBncm91cCwgc2VhcmNoIGJ5IHRpdGxlXG4gICAgICogQHBhcmFtIGdyb3VwSW5kZXggemVybyBiYXNlZCBpbmRleCBvZiB0aGUgZWRpdG9yIGdyb3VwIChsZWZ0bW9zdCBncm91cCBoYXMgaW5kZXggMCksIGRlZmF1bHQgMFxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIFdlYkVsZW1lbnQgb2JqZWN0IGlmIGZvdW5kLCB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWN0aW9uICh0aXRsZTogc3RyaW5nLCBncm91cEluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCBncm91cCA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXAoZ3JvdXBJbmRleClcbiAgICAgICAgcmV0dXJuIGdyb3VwLmdldEFjdGlvbih0aXRsZSlcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWRpdG9yR3JvdXAgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgRWRpdG9yVmlld0xvY2F0b3JzPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCByZXByZXNlbnRpbmcgYW4gZWRpdG9yIGdyb3VwXG4gKlxuICogQGNhdGVnb3J5IEVkaXRvclxuICovXG5AUGFnZURlY29yYXRvcihFZGl0b3JWaWV3TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgRWRpdG9yR3JvdXAgZXh0ZW5kcyBCYXNlUGFnZTx0eXBlb2YgRWRpdG9yVmlld0xvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdFZGl0b3JWaWV3JyBhcyBjb25zdFxuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgZWxlbWVudDogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD4sXG4gICAgICAgIHB1YmxpYyB2aWV3ID0gbmV3IEVkaXRvclZpZXcobG9jYXRvcnMpXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCBlbGVtZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3aXRjaCB0byBhbiBlZGl0b3IgdGFiIHdpdGggdGhlIGdpdmVuIHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSB0YWJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBFZGl0b3Igb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgb3BlbkVkaXRvciAodGl0bGU6IHN0cmluZyk6IFByb21pc2U8U2V0dGluZ3NFZGl0b3IgfCBEaWZmRWRpdG9yIHwgVGV4dEVkaXRvcj4ge1xuICAgICAgICBjb25zdCB0YWIgPSBhd2FpdCB0aGlzLmdldFRhYkJ5VGl0bGUodGl0bGUpXG4gICAgICAgIGF3YWl0IHRhYi5zZWxlY3QoKVxuXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnNldHRpbmdzRWRpdG9yJC5pc0V4aXN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0dGluZ3NFZGl0b3IoXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdG9yTWFwLFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICkud2FpdCgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXdhaXQgdGhpcy5kaWZmRWRpdG9yJC5pc0V4aXN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlmZkVkaXRvcihcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0b3JNYXAsXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdG9yTWFwLkVkaXRvci5lbGVtIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApLndhaXQoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RWRpdG9yKFxuICAgICAgICAgICAgdGhpcy5sb2NhdG9yTWFwLFxuICAgICAgICAgICAgdGhpcy5sb2NhdG9yTWFwLkVkaXRvci5lbGVtIGFzIHN0cmluZyxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgKS53YWl0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbiBlZGl0b3IgdGFiIHdpdGggdGhlIGdpdmVuIHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSB0YWJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSB0YWIncyBjbG9zZSBidXR0b24gaXMgcHJlc3NlZFxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlRWRpdG9yICh0aXRsZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHRhYiA9IGF3YWl0IHRoaXMuZ2V0VGFiQnlUaXRsZSh0aXRsZSlcbiAgICAgICAgYXdhaXQgdGFiLmVsZW0ubW92ZVRvKClcbiAgICAgICAgY29uc3QgY2xvc2VCdXR0b24gPSBhd2FpdCB0YWIuZWxlbS4kKHRoaXMubG9jYXRvcnMuY2xvc2VUYWIpXG4gICAgICAgIGF3YWl0IGNsb3NlQnV0dG9uLmNsaWNrKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbGwgb3BlbiBlZGl0b3IgdGFic1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIG9uY2UgYWxsIHRhYnMgaGF2ZSBoYWQgdGhlaXIgY2xvc2UgYnV0dG9uIHByZXNzZWRcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZUFsbEVkaXRvcnMgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBsZXQgdGl0bGVzID0gYXdhaXQgdGhpcy5nZXRPcGVuRWRpdG9yVGl0bGVzKClcbiAgICAgICAgd2hpbGUgKHRpdGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsb3NlRWRpdG9yKHRpdGxlc1swXSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGdyb3VwIHN0aWxsIGV4aXN0c1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZWxlbS5nZXRUYWdOYW1lKClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aXRsZXMgPSBhd2FpdCB0aGlzLmdldE9wZW5FZGl0b3JUaXRsZXMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYWxsIG9wZW4gZWRpdG9yIHRhYiB0aXRsZXMgaW4gYW4gYXJyYXlcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBlZGl0b3IgdGl0bGVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0T3BlbkVkaXRvclRpdGxlcyAoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCB0YWJzID0gYXdhaXQgdGhpcy50YWIkJFxuICAgICAgICBjb25zdCB0aXRsZXMgPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IHRhYiBvZiB0YWJzKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgY29uc3QgdGl0bGUgPSBhd2FpdCBuZXcgRWRpdG9yVGFiKHRoaXMubG9jYXRvck1hcCwgdGFiIGFzIGFueSwgdGhpcy52aWV3KS5nZXRUaXRsZSgpXG4gICAgICAgICAgICB0aXRsZXMucHVzaCh0aXRsZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGl0bGVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYW4gZWRpdG9yIHRhYiBieSB0aXRsZVxuICAgICAqIEBwYXJhbSB0aXRsZSB0aXRsZSBvZiB0aGUgdGFiXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yVGFiIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIGdldFRhYkJ5VGl0bGUgKHRpdGxlOiBzdHJpbmcpOiBQcm9taXNlPEVkaXRvclRhYj4ge1xuICAgICAgICBjb25zdCB0YWJzID0gYXdhaXQgdGhpcy50YWIkJFxuICAgICAgICBjb25zdCBhdmFpbGFibGVMYWJlbHMgPSBuZXcgU2V0KClcbiAgICAgICAgZm9yIChjb25zdCB0YWIgb2YgdGFicykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvclRhYiA9IG5ldyBFZGl0b3JUYWIodGhpcy5sb2NhdG9yTWFwLCB0YWIgYXMgYW55LCB0aGlzLnZpZXcpXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGF3YWl0IGVkaXRvclRhYi5nZXRUaXRsZSgpXG4gICAgICAgICAgICBhdmFpbGFibGVMYWJlbHMuYWRkKGxhYmVsKVxuICAgICAgICAgICAgaWYgKGxhYmVsID09PSB0aXRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3JUYWJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTm8gZWRpdG9yIHdpdGggdGl0bGUgJyR7dGl0bGV9JyBmb3VuZCwgYFxuICAgICAgICAgICAgKyBgYXZhaWxhYmxlIGVkaXRvciB3ZXJlOiAke1suLi5hdmFpbGFibGVMYWJlbHNdLmpvaW4oJywgJyl9YFxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYWxsIG9wZW4gZWRpdG9yIHRhYnNcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBFZGl0b3JUYWIgbGlzdFxuICAgICAqL1xuICAgIGFzeW5jIGdldE9wZW5UYWJzICgpOiBQcm9taXNlPEVkaXRvclRhYltdPiB7XG4gICAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYiQkXG4gICAgICAgIHJldHVybiB0YWJzLm1hcChhc3luYyAodGFiKSA9PiAoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgbmV3IEVkaXRvclRhYih0aGlzLmxvY2F0b3JNYXAsIHRhYiBhcyBhbnksIHRoaXMudmlldykud2FpdCgpXG4gICAgICAgICkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGFjdGl2ZSBlZGl0b3IgdGFiXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yVGFiIG9iamVjdCwgdW5kZWZpbmVkIGlmIG5vIHRhYiBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3RpdmVUYWIgKCk6IFByb21pc2U8RWRpdG9yVGFiIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHRhYnMgPSBhd2FpdCB0aGlzLmdldE9wZW5UYWJzKClcbiAgICAgICAgY29uc3Qga2xhc3NlcyA9IGF3YWl0IFByb21pc2UuYWxsKHRhYnMubWFwKGFzeW5jICh0YWIpID0+IHRhYi5lbGVtLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkpXG4gICAgICAgIGNvbnN0IGluZGV4ID0ga2xhc3Nlcy5maW5kSW5kZXgoKGtsYXNzKSA9PiBrbGFzcy5pbmRleE9mKCdhY3RpdmUnKSA+IC0xKVxuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFic1tpbmRleF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGVkaXRvciBhY3Rpb24gYnV0dG9ucyBhcyBXZWJFbGVtZW50c1xuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIGxpc3Qgb2YgV2ViRWxlbWVudCBvYmplY3RzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWN0aW9ucyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbkNvbnRhaW5lciQuJCQodGhpcy5sb2NhdG9ycy5hY3Rpb25JdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW4gZWRpdG9yIGFjdGlvbiBidXR0b24gYnkgdGl0bGVcbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIGJ1dHRvblxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIFdlYkVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBidXR0b24gaWYgZm91bmQsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3Rpb24gKHRpdGxlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0QWN0aW9ucygpXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgaXRlbS5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgPT09IHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVkaXRvclRhYiBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBFZGl0b3JMb2NhdG9yc09iaj4ge31cbi8qKlxuICogUGFnZSBvYmplY3QgZm9yIGVkaXRvciB2aWV3IHRhYlxuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoRWRpdG9yTG9jYXRvcnNPYmopXG5leHBvcnQgY2xhc3MgRWRpdG9yVGFiIGV4dGVuZHMgRWxlbWVudFdpdGhDb250ZXh0TWVudTx0eXBlb2YgRWRpdG9yTG9jYXRvcnNPYmo+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ0VkaXRvcicgYXMgY29uc3RcblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIGVsZW1lbnQ6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+LFxuICAgICAgICBwdWJsaWMgdmlldzogRWRpdG9yVmlld1xuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgZWxlbWVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRhYiB0aXRsZSBhcyBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUaXRsZSAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGUkLmdldFRleHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCAoY2xpY2spIHRoZSB0YWJcbiAgICAgKi9cbiAgICBhc3luYyBzZWxlY3QgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLmVsZW0uY2xpY2soKVxuICAgIH1cbn1cbiJdfQ==