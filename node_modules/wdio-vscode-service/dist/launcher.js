import fs from 'node:fs/promises';
import path from 'node:path';
import { format } from 'node:util';
import downloadBundle from 'download';
import logger from '@wdio/logger';
import { setGlobalDispatcher, request, ProxyAgent } from 'undici';
import { download } from '@vscode/test-electron';
import { SevereServiceError } from 'webdriverio';
import { HttpsProxyAgent } from 'hpagent';
import startServer from './server/index.js';
import { fileExist, directoryExists } from './utils.js';
import { DEFAULT_CHANNEL, VSCODE_RELEASES, VSCODE_MANIFEST_URL, DEFAULT_CACHE_PATH, VSCODE_CAPABILITY_KEY, VSCODE_WEB_STANDALONE, DEFAULT_VSCODE_WEB_HOSTNAME } from './constants.js';
// set up proxy if environment variable HTTPS_PROXY or https_proxy is set
let downloadAgentConfiguration;
const httpsProxy = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.npm_config_proxy;
if (httpsProxy) {
    const proxyUrl = new URL(httpsProxy);
    const token = proxyUrl.username && proxyUrl.password
        ? `Basic ${btoa(`${proxyUrl.username}:${proxyUrl.password}`)}`
        : undefined;
    setGlobalDispatcher(new ProxyAgent({ uri: proxyUrl.protocol + proxyUrl.host, token }));
    // @ts-expect-error downloadAgentConfiguration is not part of the official API
    downloadAgentConfiguration = { agent: new HttpsProxyAgent({ proxy: proxyUrl }) };
}
// use HTTPS_PROXY or https_proxy for @vscode/test-electron if not already set
if (httpsProxy !== process.env.npm_config_proxy) {
    process.env.npm_config_proxy = httpsProxy;
}
const VERSIONS_TXT = 'versions.txt';
const log = logger('wdio-vscode-service/launcher');
export default class VSCodeServiceLauncher {
    constructor(_options) {
        this._options = _options;
        this._cachePath = this._options.cachePath || DEFAULT_CACHE_PATH;
    }
    async onPrepare(_, capabilities) {
        const caps = Array.isArray(capabilities)
            ? capabilities.map((c) => (c.alwaysMatch || c))
            : Object.values(capabilities).map((c) => c.capabilities);
        /**
         * Check if we already have the VS Code bundle for the given version
         * and continue without download if possible
         */
        const versionsFilePath = path.join(this._cachePath, VERSIONS_TXT);
        const versionsFileExist = await fileExist(versionsFilePath);
        for (const cap of caps) {
            /**
             * skip setup if user is not using VSCode as capability
             */
            if (typeof cap.browserName !== 'string' || !cap[VSCODE_CAPABILITY_KEY]) {
                continue;
            }
            const version = cap[VSCODE_CAPABILITY_KEY].version || cap.browserVersion || DEFAULT_CHANNEL;
            /**
             * setup VSCode Desktop
             */
            if (cap.browserName === 'vscode') {
                await this._setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap);
                continue;
            }
            /**
             * setup VSCode Web
             */
            await this._setupVSCodeWeb(version, cap);
        }
    }
    /**
     * Set up VSCode for web testing
     * @param versionsFileExist true if we already have information stored about cached VSCode bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeWeb(version, cap) {
        /**
         * no need to do any work if we already started the server
         */
        if (this._vscodeServerPort || !cap[VSCODE_CAPABILITY_KEY]) {
            return;
        }
        try {
            const vscodeStandalone = await this._fetchVSCodeWebStandalone(version);
            const port = await startServer(vscodeStandalone, cap[VSCODE_CAPABILITY_KEY]);
            cap[VSCODE_CAPABILITY_KEY].serverOptions = {
                ...(cap[VSCODE_CAPABILITY_KEY].serverOptions || {
                    hostname: DEFAULT_VSCODE_WEB_HOSTNAME
                }),
                port
            };
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't start server for VSCode Web: ${err.message}`);
        }
    }
    /**
     * Set up VSCode for desktop testing
     * @param versionsFileExist true if we already have information stored about cached VSCode bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap) {
        if (!cap[VSCODE_CAPABILITY_KEY]) {
            throw new Error(`No key "${VSCODE_CAPABILITY_KEY}" found in caps`);
        }
        if (versionsFileExist) {
            const content = JSON.parse((await fs.readFile(versionsFilePath, 'utf-8')).toString());
            const vscodeVersion = content[version]?.vscode;
            const chromedriverVersion = content[version]?.chromedriver;
            const vscodePath = cap[VSCODE_CAPABILITY_KEY]?.binary
                || path.join(this._cachePath, `vscode-${process.platform}-${process.arch}-${vscodeVersion}`);
            if (vscodeVersion && chromedriverVersion && await fileExist(vscodePath)) {
                log.info(`Skipping download, bundle for VSCode v${vscodeVersion} already exists`);
                cap.browserVersion = chromedriverVersion;
                cap[VSCODE_CAPABILITY_KEY].binary ||= await this._downloadVSCode(vscodeVersion);
                return;
            }
        }
        const vscodeVersion = await this._fetchVSCodeVersion(version);
        const chromedriverVersion = await this._fetchChromedriverVersion(vscodeVersion);
        cap.browserVersion = chromedriverVersion;
        cap[VSCODE_CAPABILITY_KEY].binary ||= await this._downloadVSCode(vscodeVersion);
        await this._updateVersionsTxt(version, vscodeVersion, chromedriverVersion, versionsFileExist);
    }
    /**
     * Download VSCode bundle
     * @param version VSCode version
     * @returns path to downloaded VSCode bundle
     */
    async _downloadVSCode(version) {
        try {
            log.info(`Download VSCode binary (${version})`);
            return await download({
                cachePath: this._cachePath,
                version
            });
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up VSCode: ${err.message}`);
        }
    }
    /**
     * Get VSCode version based on desired channel or validate version if provided
     * @param desiredReleaseChannel either release channel (e.g. "stable" or "insiders")
     *                              or a concrete version e.g. 1.66.0
     * @returns "main" if `desiredReleaseChannel` is "insiders" otherwise a concrete VSCode version
     */
    async _fetchVSCodeVersion(desiredReleaseChannel) {
        if (desiredReleaseChannel === 'insiders') {
            return 'main';
        }
        try {
            log.info(`Fetch releases from ${VSCODE_RELEASES}`);
            const { body: versions } = await request(VSCODE_RELEASES, {});
            const availableVersions = await versions.json();
            if (desiredReleaseChannel) {
                /**
                 * validate provided VSCode version
                 */
                const newDesiredReleaseChannel = desiredReleaseChannel === 'stable'
                    ? availableVersions[0]
                    : desiredReleaseChannel;
                if (!availableVersions.includes(newDesiredReleaseChannel)) {
                    throw new Error(`Desired version "${newDesiredReleaseChannel}" is not existent, available versions:`
                        + `${availableVersions.slice(0, 5).join(', ')}..., see ${VSCODE_RELEASES}`);
                }
                return newDesiredReleaseChannel;
            }
            return availableVersions[0];
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't fetch latest VSCode: ${err.message}`);
        }
    }
    /**
     * Fetches required Chromedriver version for given VSCode version
     * @param vscodeVersion branch or tag version of VSCode repository
     * @returns required Chromedriver version
     */
    async _fetchChromedriverVersion(vscodeVersion) {
        try {
            const { body } = await request(format(VSCODE_MANIFEST_URL, vscodeVersion), {});
            const manifest = await body.json();
            const chromium = manifest.registrations.find((r) => r.component.git.name === 'chromium');
            if (!chromium) {
                throw new Error('Can\'t find chromium version in manifest response');
            }
            return chromium.version.split('.')[0];
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't fetch Chromedriver version: ${err.message}`);
        }
    }
    /**
     * Fetches VSCode Web files
     * ToDo(Christian): allow to define a local VSCode development path
     *                  to be able to skip this part
     */
    async _fetchVSCodeWebStandalone(vscodeVersion) {
        if (vscodeVersion !== 'stable' && vscodeVersion !== 'insiders') {
            throw new Error('Running VSCode in the browser is only supported for "stable" and "insiders" version');
        }
        try {
            const { body } = await request(format(VSCODE_WEB_STANDALONE, vscodeVersion), {});
            const info = await body.json();
            const folder = path.join(this._cachePath, `vscode-web-${vscodeVersion}-${info.version}`);
            if (!(await directoryExists(folder))) {
                await downloadBundle(info.url, folder, { extract: true, strip: 1, ...downloadAgentConfiguration });
            }
            return { path: folder, vscodeVersion, version: info.version };
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up VSCode Web: ${err.message}`);
        }
    }
    async _updateVersionsTxt(version, vscodeVersion, chromedriverVersion, versionsFileExist) {
        const newContent = {
            [version]: {
                chromedriver: chromedriverVersion,
                vscode: vscodeVersion
            }
        };
        const versionsTxtPath = path.join(this._cachePath, VERSIONS_TXT);
        if (!versionsFileExist) {
            return fs.writeFile(versionsTxtPath, JSON.stringify(newContent, null, 4), 'utf-8');
        }
        const content = JSON.parse((await fs.readFile(versionsTxtPath, 'utf-8')).toString());
        return fs.writeFile(versionsTxtPath, JSON.stringify({ ...content, ...newContent }, null, 4), 'utf-8');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF1bmNoZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbGF1bmNoZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sa0JBQWtCLENBQUE7QUFDakMsT0FBTyxJQUFJLE1BQU0sV0FBVyxDQUFBO0FBQzVCLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxXQUFXLENBQUE7QUFFbEMsT0FBTyxjQUFtQyxNQUFNLFVBQVUsQ0FBQTtBQUMxRCxPQUFPLE1BQU0sTUFBTSxjQUFjLENBQUE7QUFDakMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxRQUFRLENBQUE7QUFDakUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLHVCQUF1QixDQUFBO0FBQ2hELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGFBQWEsQ0FBQTtBQUVoRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sU0FBUyxDQUFBO0FBRXpDLE9BQU8sV0FBVyxNQUFNLG1CQUFtQixDQUFBO0FBQzNDLE9BQU8sRUFBRSxTQUFTLEVBQUUsZUFBZSxFQUFFLE1BQU0sWUFBWSxDQUFBO0FBQ3ZELE9BQU8sRUFDSCxlQUFlLEVBQUUsZUFBZSxFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUN6RSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSwyQkFBMkIsRUFDNUUsTUFBTSxnQkFBZ0IsQ0FBQTtBQXVCdkIseUVBQXlFO0FBQ3pFLElBQUksMEJBQWdFLENBQUE7QUFDcEUsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQTtBQUNyRyxJQUFJLFVBQVUsRUFBRSxDQUFDO0lBQ2IsTUFBTSxRQUFRLEdBQUcsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUE7SUFDcEMsTUFBTSxL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QVksRUFBRSxtQkFBbUI7Z0JBQ2pDLE1BQU0sRUFBRSxhQUFhO2FBQ3hCO1NBQ0osQ0FBQTtRQUNELE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsQ0FBQTtRQUNoRSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUNyQixPQUFPLEVBQUUsQ0FBQyxTQUFTLENBQ2YsZUFBZSxFQUNmLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFDbkMsT0FBTyxDQUNWLENBQUE7UUFDTCxDQUFDO1FBRUQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFBO1FBQ3BGLE9BQU8sRUFBRSxDQUFDLFNBQVMsQ0FDZixlQUFlLEVBQ2YsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEdBQUcsT0FBTyxFQUFFLEdBQUcsVUFBVSxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUN0RCxPQUFPLENBQ1YsQ0FBQTtJQUNMLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdub2RlOmZzL3Byb21pc2VzJ1xuaW1wb3J0IHBhdGggZnJvbSAnbm9kZTpwYXRoJ1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnbm9kZTp1dGlsJ1xuXG5pbXBvcnQgZG93bmxvYWRCdW5kbGUsIHsgRG93bmxvYWRPcHRpb25zIH0gZnJvbSAnZG93bmxvYWQnXG5pbXBvcnQgbG9nZ2VyIGZyb20gJ0B3ZGlvL2xvZ2dlcidcbmltcG9ydCB7IHNldEdsb2JhbERpc3BhdGNoZXIsIHJlcXVlc3QsIFByb3h5QWdlbnQgfSBmcm9tICd1bmRpY2knXG5pbXBvcnQgeyBkb3dubG9hZCB9IGZyb20gJ0B2c2NvZGUvdGVzdC1lbGVjdHJvbidcbmltcG9ydCB7IFNldmVyZVNlcnZpY2VFcnJvciB9IGZyb20gJ3dlYmRyaXZlcmlvJ1xuaW1wb3J0IHR5cGUgeyBDYXBhYmlsaXRpZXMgfSBmcm9tICdAd2Rpby90eXBlcydcbmltcG9ydCB7IEh0dHBzUHJveHlBZ2VudCB9IGZyb20gJ2hwYWdlbnQnXG5cbmltcG9ydCBzdGFydFNlcnZlciBmcm9tICcuL3NlcnZlci9pbmRleC5qcydcbmltcG9ydCB7IGZpbGVFeGlzdCwgZGlyZWN0b3J5RXhpc3RzIH0gZnJvbSAnLi91dGlscy5qcydcbmltcG9ydCB7XG4gICAgREVGQVVMVF9DSEFOTkVMLCBWU0NPREVfUkVMRUFTRVMsIFZTQ09ERV9NQU5JRkVTVF9VUkwsIERFRkFVTFRfQ0FDSEVfUEFUSCxcbiAgICBWU0NPREVfQ0FQQUJJTElUWV9LRVksIFZTQ09ERV9XRUJfU1RBTkRBTE9ORSwgREVGQVVMVF9WU0NPREVfV0VCX0hPU1ROQU1FXG59IGZyb20gJy4vY29uc3RhbnRzLmpzJ1xuaW1wb3J0IHR5cGUge1xuICAgIFNlcnZpY2VPcHRpb25zLCBWU0NvZGVDYXBhYmlsaXRpZXMsIFdlYlN0YW5kYWxvbmVSZXNwb25zZSxcbiAgICBCdW5kbGVcbn0gZnJvbSAnLi90eXBlcy5qcydcblxuaW50ZXJmYWNlIEJ1bmRlSW5mb3JtYXRpb24ge1xuICAgIGNocm9tZWRyaXZlcjogc3RyaW5nXG4gICAgdnNjb2RlOiBzdHJpbmdcbn1cbmludGVyZmFjZSBNYW5pZmVzdCB7XG4gICAgcmVnaXN0cmF0aW9uczogUmVnaXN0cmF0aW9uW11cbn1cbmludGVyZmFjZSBSZWdpc3RyYXRpb24ge1xuICAgIHZlcnNpb246IHN0cmluZ1xuICAgIGNvbXBvbmVudDoge1xuICAgICAgICBnaXQ6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICB9XG4gICAgfVxufVxudHlwZSBWZXJzaW9ucyA9IHsgW2Rlc2lyZWRWZXJzaW9uOiBzdHJpbmddOiBCdW5kZUluZm9ybWF0aW9uIHwgdW5kZWZpbmVkIH1cblxuLy8gc2V0IHVwIHByb3h5IGlmIGVudmlyb25tZW50IHZhcmlhYmxlIEhUVFBTX1BST1hZIG9yIGh0dHBzX3Byb3h5IGlzIHNldFxubGV0IGRvd25sb2FkQWdlbnRDb25maWd1cmF0aW9uOiBQYXJ0aWFsPERvd25sb2FkT3B0aW9ucz4gfCB1bmRlZmluZWRcbmNvbnN0IGh0dHBzUHJveHkgPSBwcm9jZXNzLmVudi5IVFRQU19QUk9YWSB8fCBwcm9jZXNzLmVudi5odHRwc19wcm94eSB8fCBwcm9jZXNzLmVudi5ucG1fY29uZmlnX3Byb3h5XG5pZiAoaHR0cHNQcm94eSkge1xuICAgIGNvbnN0IHByb3h5VXJsID0gbmV3IFVSTChodHRwc1Byb3h5KVxuICAgIGNvbnN0IHRva2VuID0gcHJveHlVcmwudXNlcm5hbWUgJiYgcHJveHlVcmwucGFzc3dvcmRcbiAgICAgICAgPyBgQmFzaWMgJHtidG9hKGAke3Byb3h5VXJsLnVzZXJuYW1lfToke3Byb3h5VXJsLnBhc3N3b3JkfWApfWBcbiAgICAgICAgOiB1bmRlZmluZWRcblxuICAgIHNldEdsb2JhbERpc3BhdGNoZXIobmV3IFByb3h5QWdlbnQoeyB1cmk6IHByb3h5VXJsLnByb3RvY29sICsgcHJveHlVcmwuaG9zdCwgdG9rZW4gfSkpXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBkb3dubG9hZEFnZW50Q29uZmlndXJhdGlvbiBpcyBub3QgcGFydCBvZiB0aGUgb2ZmaWNpYWwgQVBJXG4gICAgZG93bmxvYWRBZ2VudENvbmZpZ3VyYXRpb24gPSB7IGFnZW50OiBuZXcgSHR0cHNQcm94eUFnZW50KHsgcHJveHk6IHByb3h5VXJsIH0pIH1cbn1cbi8vIHVzZSBIVFRQU19QUk9YWSBvciBodHRwc19wcm94eSBmb3IgQHZzY29kZS90ZXN0LWVsZWN0cm9uIGlmIG5vdCBhbHJlYWR5IHNldFxuaWYgKGh0dHBzUHJveHkgIT09IHByb2Nlc3MuZW52Lm5wbV9jb25maWdfcHJveHkpIHtcbiAgICBwcm9jZXNzLmVudi5ucG1fY29uZmlnX3Byb3h5ID0gaHR0cHNQcm94eVxufVxuXG5jb25zdCBWRVJTSU9OU19UWFQgPSAndmVyc2lvbnMudHh0J1xuY29uc3QgbG9nID0gbG9nZ2VyKCd3ZGlvLXZzY29kZS1zZXJ2aWNlL2xhdW5jaGVyJylcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZTQ29kZVNlcnZpY2VMYXVuY2hlciB7XG4gICAgcHJpdmF0ZSBfY2FjaGVQYXRoOiBzdHJpbmdcbiAgICBwcml2YXRlIF92c2NvZGVTZXJ2ZXJQb3J0PzogbnVtYmVyXG5cbiAgICBjb25zdHJ1Y3RvciAocHJpdmF0ZSBfb3B0aW9uczogU2VydmljZU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVQYXRoID0gdGhpcy5fb3B0aW9ucy5jYWNoZVBhdGggfHwgREVGQVVMVF9DQUNIRV9QQVRIXG4gICAgfVxuXG4gICAgYXN5bmMgb25QcmVwYXJlIChfOiBuZXZlciwgY2FwYWJpbGl0aWVzOiBDYXBhYmlsaXRpZXMuUmVtb3RlQ2FwYWJpbGl0aWVzKSB7XG4gICAgICAgIGNvbnN0IGNhcHM6IFZTQ29kZUNhcGFiaWxpdGllc1tdID0gQXJyYXkuaXNBcnJheShjYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICA/IGNhcGFiaWxpdGllcy5tYXAoKGMpID0+ICgoYyBhcyBDYXBhYmlsaXRpZXMuVzNDQ2FwYWJpbGl0aWVzKS5hbHdheXNNYXRjaCB8fCBjKSBhcyBWU0NvZGVDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICA6IE9iamVjdC52YWx1ZXMoY2FwYWJpbGl0aWVzKS5tYXAoKGMpID0+IGMuY2FwYWJpbGl0aWVzIGFzIFZTQ29kZUNhcGFiaWxpdGllcylcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBWUyBDb2RlIGJ1bmRsZSBmb3IgdGhlIGdpdmVuIHZlcnNpb25cbiAgICAgICAgICogYW5kIGNvbnRpbnVlIHdpdGhvdXQgZG93bmxvYWQgaWYgcG9zc2libGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHZlcnNpb25zRmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5fY2FjaGVQYXRoLCBWRVJTSU9OU19UWFQpXG4gICAgICAgIGNvbnN0IHZlcnNpb25zRmlsZUV4aXN0ID0gYXdhaXQgZmlsZUV4aXN0KHZlcnNpb25zRmlsZVBhdGgpXG5cbiAgICAgICAgZm9yIChjb25zdCBjYXAgb2YgY2Fwcykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBza2lwIHNldHVwIGlmIHVzZXIgaXMgbm90IHVzaW5nIFZTQ29kZSBhcyBjYXBhYmlsaXR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FwLmJyb3dzZXJOYW1lICE9PSAnc3RyaW5nJyB8fCAhY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0udmVyc2lvbiB8fCBjYXAuYnJvd3NlclZlcnNpb24gfHwgREVGQVVMVF9DSEFOTkVMXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc2V0dXAgVlNDb2RlIERlc2t0b3BcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGNhcC5icm93c2VyTmFtZSA9PT0gJ3ZzY29kZScpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFZTQ29kZURlc2t0b3AodmVyc2lvbnNGaWxlRXhpc3QsIHZlcnNpb25zRmlsZVBhdGgsIHZlcnNpb24sIGNhcClcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHNldHVwIFZTQ29kZSBXZWJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBWU0NvZGVXZWIodmVyc2lvbiwgY2FwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIFZTQ29kZSBmb3Igd2ViIHRlc3RpbmdcbiAgICAgKiBAcGFyYW0gdmVyc2lvbnNGaWxlRXhpc3QgdHJ1ZSBpZiB3ZSBhbHJlYWR5IGhhdmUgaW5mb3JtYXRpb24gc3RvcmVkIGFib3V0IGNhY2hlZCBWU0NvZGUgYnVuZGxlc1xuICAgICAqIEBwYXJhbSB2ZXJzaW9uc0ZpbGVQYXRoIHN0cmluZyB3aXRoIHBhdGggdG8gY2FjaGVkIGRpcmVjdG9yeVxuICAgICAqIEBwYXJhbSBjYXAgY2FwYWJpbGl0aWVzIHVzZWQgZm9yIHRoaXMgdGVzdCBydW5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cFZTQ29kZVdlYiAoXG4gICAgICAgIHZlcnNpb246IHN0cmluZyxcbiAgICAgICAgY2FwOiBWU0NvZGVDYXBhYmlsaXRpZXNcbiAgICApIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5vIG5lZWQgdG8gZG8gYW55IHdvcmsgaWYgd2UgYWxyZWFkeSBzdGFydGVkIHRoZSBzZXJ2ZXJcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLl92c2NvZGVTZXJ2ZXJQb3J0IHx8ICFjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdnNjb2RlU3RhbmRhbG9uZSA9IGF3YWl0IHRoaXMuX2ZldGNoVlNDb2RlV2ViU3RhbmRhbG9uZSh2ZXJzaW9uKVxuICAgICAgICAgICAgY29uc3QgcG9ydCA9IGF3YWl0IHN0YXJ0U2VydmVyKHZzY29kZVN0YW5kYWxvbmUsIGNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldKVxuICAgICAgICAgICAgY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0uc2VydmVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAuLi4oY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0uc2VydmVyT3B0aW9ucyB8fCB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RuYW1lOiBERUZBVUxUX1ZTQ09ERV9XRUJfSE9TVE5BTUVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBwb3J0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2V2ZXJlU2VydmljZUVycm9yKGBDb3VsZG4ndCBzdGFydCBzZXJ2ZXIgZm9yIFZTQ29kZSBXZWI6ICR7ZXJyLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB1cCBWU0NvZGUgZm9yIGRlc2t0b3AgdGVzdGluZ1xuICAgICAqIEBwYXJhbSB2ZXJzaW9uc0ZpbGVFeGlzdCB0cnVlIGlmIHdlIGFscmVhZHkgaGF2ZSBpbmZvcm1hdGlvbiBzdG9yZWQgYWJvdXQgY2FjaGVkIFZTQ29kZSBidW5kbGVzXG4gICAgICogQHBhcmFtIHZlcnNpb25zRmlsZVBhdGggc3RyaW5nIHdpdGggcGF0aCB0byBjYWNoZWQgZGlyZWN0b3J5XG4gICAgICogQHBhcmFtIGNhcCBjYXBhYmlsaXRpZXMgdXNlZCBmb3IgdGhpcyB0ZXN0IHJ1blxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX3NldHVwVlNDb2RlRGVza3RvcCAoXG4gICAgICAgIHZlcnNpb25zRmlsZUV4aXN0OiBib29sZWFuLFxuICAgICAgICB2ZXJzaW9uc0ZpbGVQYXRoOiBzdHJpbmcsXG4gICAgICAgIHZlcnNpb246IHN0cmluZyxcbiAgICAgICAgY2FwOiBWU0NvZGVDYXBhYmlsaXRpZXNcbiAgICApIHtcbiAgICAgICAgaWYgKCFjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBrZXkgXCIke1ZTQ09ERV9DQVBBQklMSVRZX0tFWX1cIiBmb3VuZCBpbiBjYXBzYClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2ZXJzaW9uc0ZpbGVFeGlzdCkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IEpTT04ucGFyc2UoKGF3YWl0IGZzLnJlYWRGaWxlKHZlcnNpb25zRmlsZVBhdGgsICd1dGYtOCcpKS50b1N0cmluZygpKSBhcyBWZXJzaW9uc1xuXG4gICAgICAgICAgICBjb25zdCB2c2NvZGVWZXJzaW9uID0gY29udGVudFt2ZXJzaW9uXT8udnNjb2RlXG4gICAgICAgICAgICBjb25zdCBjaHJvbWVkcml2ZXJWZXJzaW9uID0gY29udGVudFt2ZXJzaW9uXT8uY2hyb21lZHJpdmVyXG4gICAgICAgICAgICBjb25zdCB2c2NvZGVQYXRoID0gY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0/LmJpbmFyeVxuICAgICAgICAgICAgICAgIHx8IHBhdGguam9pbih0aGlzLl9jYWNoZVBhdGgsIGB2c2NvZGUtJHtwcm9jZXNzLnBsYXRmb3JtfS0ke3Byb2Nlc3MuYXJjaH0tJHt2c2NvZGVWZXJzaW9ufWApXG5cbiAgICAgICAgICAgIGlmICh2c2NvZGVWZXJzaW9uICYmIGNocm9tZWRyaXZlclZlcnNpb24gJiYgYXdhaXQgZmlsZUV4aXN0KHZzY29kZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oXG4gICAgICAgICAgICAgICAgICAgIGBTa2lwcGluZyBkb3dubG9hZCwgYnVuZGxlIGZvciBWU0NvZGUgdiR7dnNjb2RlVmVyc2lvbn0gYWxyZWFkeSBleGlzdHNgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGNhcC5icm93c2VyVmVyc2lvbiA9IGNocm9tZWRyaXZlclZlcnNpb25cbiAgICAgICAgICAgICAgICBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXS5iaW5hcnkgfHw9IGF3YWl0IHRoaXMuX2Rvd25sb2FkVlNDb2RlKHZzY29kZVZlcnNpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2c2NvZGVWZXJzaW9uID0gYXdhaXQgdGhpcy5fZmV0Y2hWU0NvZGVWZXJzaW9uKHZlcnNpb24pXG4gICAgICAgIGNvbnN0IGNocm9tZWRyaXZlclZlcnNpb24gPSBhd2FpdCB0aGlzLl9mZXRjaENocm9tZWRyaXZlclZlcnNpb24odnNjb2RlVmVyc2lvbilcblxuICAgICAgICBjYXAuYnJvd3NlclZlcnNpb24gPSBjaHJvbWVkcml2ZXJWZXJzaW9uXG4gICAgICAgIGNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldLmJpbmFyeSB8fD0gYXdhaXQgdGhpcy5fZG93bmxvYWRWU0NvZGUodnNjb2RlVmVyc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlVmVyc2lvbnNUeHQodmVyc2lvbiwgdnNjb2RlVmVyc2lvbiwgY2hyb21lZHJpdmVyVmVyc2lvbiwgdmVyc2lvbnNGaWxlRXhpc3QpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgVlNDb2RlIGJ1bmRsZVxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFZTQ29kZSB2ZXJzaW9uXG4gICAgICogQHJldHVybnMgcGF0aCB0byBkb3dubG9hZGVkIFZTQ29kZSBidW5kbGVcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIF9kb3dubG9hZFZTQ29kZSAodmVyc2lvbjogc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2cuaW5mbyhgRG93bmxvYWQgVlNDb2RlIGJpbmFyeSAoJHt2ZXJzaW9ufSlgKVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGRvd25sb2FkKHtcbiAgICAgICAgICAgICAgICBjYWNoZVBhdGg6IHRoaXMuX2NhY2hlUGF0aCxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNldmVyZVNlcnZpY2VFcnJvcihgQ291bGRuJ3Qgc2V0IHVwIFZTQ29kZTogJHtlcnIubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IFZTQ29kZSB2ZXJzaW9uIGJhc2VkIG9uIGRlc2lyZWQgY2hhbm5lbCBvciB2YWxpZGF0ZSB2ZXJzaW9uIGlmIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIGRlc2lyZWRSZWxlYXNlQ2hhbm5lbCBlaXRoZXIgcmVsZWFzZSBjaGFubmVsIChlLmcuIFwic3RhYmxlXCIgb3IgXCJpbnNpZGVyc1wiKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYSBjb25jcmV0ZSB2ZXJzaW9uIGUuZy4gMS42Ni4wXG4gICAgICogQHJldHVybnMgXCJtYWluXCIgaWYgYGRlc2lyZWRSZWxlYXNlQ2hhbm5lbGAgaXMgXCJpbnNpZGVyc1wiIG90aGVyd2lzZSBhIGNvbmNyZXRlIFZTQ29kZSB2ZXJzaW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfZmV0Y2hWU0NvZGVWZXJzaW9uIChkZXNpcmVkUmVsZWFzZUNoYW5uZWw/OiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKGRlc2lyZWRSZWxlYXNlQ2hhbm5lbCA9PT0gJ2luc2lkZXJzJykge1xuICAgICAgICAgICAgcmV0dXJuICdtYWluJ1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBGZXRjaCByZWxlYXNlcyBmcm9tICR7VlNDT0RFX1JFTEVBU0VTfWApXG4gICAgICAgICAgICBjb25zdCB7IGJvZHk6IHZlcnNpb25zIH0gPSBhd2FpdCByZXF1ZXN0KFZTQ09ERV9SRUxFQVNFUywge30pXG4gICAgICAgICAgICBjb25zdCBhdmFpbGFibGVWZXJzaW9uczogc3RyaW5nW10gPSBhd2FpdCB2ZXJzaW9ucy5qc29uKCkgYXMgc3RyaW5nW11cblxuICAgICAgICAgICAgaWYgKGRlc2lyZWRSZWxlYXNlQ2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIHZhbGlkYXRlIHByb3ZpZGVkIFZTQ29kZSB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGVzaXJlZFJlbGVhc2VDaGFubmVsID0gZGVzaXJlZFJlbGVhc2VDaGFubmVsID09PSAnc3RhYmxlJ1xuICAgICAgICAgICAgICAgICAgICA/IGF2YWlsYWJsZVZlcnNpb25zWzBdXG4gICAgICAgICAgICAgICAgICAgIDogZGVzaXJlZFJlbGVhc2VDaGFubmVsXG4gICAgICAgICAgICAgICAgaWYgKCFhdmFpbGFibGVWZXJzaW9ucy5pbmNsdWRlcyhuZXdEZXNpcmVkUmVsZWFzZUNoYW5uZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBEZXNpcmVkIHZlcnNpb24gXCIke25ld0Rlc2lyZWRSZWxlYXNlQ2hhbm5lbH1cIiBpcyBub3QgZXhpc3RlbnQsIGF2YWlsYWJsZSB2ZXJzaW9uczpgXG4gICAgICAgICAgICAgICAgICAgICAgICArIGAke2F2YWlsYWJsZVZlcnNpb25zLnNsaWNlKDAsIDUpLmpvaW4oJywgJyl9Li4uLCBzZWUgJHtWU0NPREVfUkVMRUFTRVN9YFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Rlc2lyZWRSZWxlYXNlQ2hhbm5lbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlVmVyc2lvbnNbMF1cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXZlcmVTZXJ2aWNlRXJyb3IoYENvdWxkbid0IGZldGNoIGxhdGVzdCBWU0NvZGU6ICR7ZXJyLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgcmVxdWlyZWQgQ2hyb21lZHJpdmVyIHZlcnNpb24gZm9yIGdpdmVuIFZTQ29kZSB2ZXJzaW9uXG4gICAgICogQHBhcmFtIHZzY29kZVZlcnNpb24gYnJhbmNoIG9yIHRhZyB2ZXJzaW9uIG9mIFZTQ29kZSByZXBvc2l0b3J5XG4gICAgICogQHJldHVybnMgcmVxdWlyZWQgQ2hyb21lZHJpdmVyIHZlcnNpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIF9mZXRjaENocm9tZWRyaXZlclZlcnNpb24gKHZzY29kZVZlcnNpb246IHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBib2R5IH0gPSBhd2FpdCByZXF1ZXN0KGZvcm1hdChWU0NPREVfTUFOSUZFU1RfVVJMLCB2c2NvZGVWZXJzaW9uKSwge30pXG4gICAgICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IGJvZHkuanNvbigpIGFzIE1hbmlmZXN0XG4gICAgICAgICAgICBjb25zdCBjaHJvbWl1bSA9IG1hbmlmZXN0LnJlZ2lzdHJhdGlvbnMuZmluZCgocjogYW55KSA9PiByLmNvbXBvbmVudC5naXQubmFtZSA9PT0gJ2Nocm9taXVtJylcblxuICAgICAgICAgICAgaWYgKCFjaHJvbWl1bSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBmaW5kIGNocm9taXVtIHZlcnNpb24gaW4gbWFuaWZlc3QgcmVzcG9uc2UnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2hyb21pdW0udmVyc2lvbi5zcGxpdCgnLicpWzBdXG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2V2ZXJlU2VydmljZUVycm9yKGBDb3VsZG4ndCBmZXRjaCBDaHJvbWVkcml2ZXIgdmVyc2lvbjogJHtlcnIubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBWU0NvZGUgV2ViIGZpbGVzXG4gICAgICogVG9EbyhDaHJpc3RpYW4pOiBhbGxvdyB0byBkZWZpbmUgYSBsb2NhbCBWU0NvZGUgZGV2ZWxvcG1lbnQgcGF0aFxuICAgICAqICAgICAgICAgICAgICAgICAgdG8gYmUgYWJsZSB0byBza2lwIHRoaXMgcGFydFxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX2ZldGNoVlNDb2RlV2ViU3RhbmRhbG9uZSAodnNjb2RlVmVyc2lvbjogc3RyaW5nKTogUHJvbWlzZTxCdW5kbGU+IHtcbiAgICAgICAgaWYgKHZzY29kZVZlcnNpb24gIT09ICdzdGFibGUnICYmIHZzY29kZVZlcnNpb24gIT09ICdpbnNpZGVycycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUnVubmluZyBWU0NvZGUgaW4gdGhlIGJyb3dzZXIgaXMgb25seSBzdXBwb3J0ZWQgZm9yIFwic3RhYmxlXCIgYW5kIFwiaW5zaWRlcnNcIiB2ZXJzaW9uJylcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGJvZHkgfSA9IGF3YWl0IHJlcXVlc3QoZm9ybWF0KFZTQ09ERV9XRUJfU1RBTkRBTE9ORSwgdnNjb2RlVmVyc2lvbiksIHt9KVxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IGJvZHkuanNvbigpIGFzIFdlYlN0YW5kYWxvbmVSZXNwb25zZVxuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gcGF0aC5qb2luKHRoaXMuX2NhY2hlUGF0aCwgYHZzY29kZS13ZWItJHt2c2NvZGVWZXJzaW9ufS0ke2luZm8udmVyc2lvbn1gKVxuXG4gICAgICAgICAgICBpZiAoIShhd2FpdCBkaXJlY3RvcnlFeGlzdHMoZm9sZGVyKSkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkb3dubG9hZEJ1bmRsZShpbmZvLnVybCwgZm9sZGVyLCB7IGV4dHJhY3Q6IHRydWUsIHN0cmlwOiAxLCAuLi5kb3dubG9hZEFnZW50Q29uZmlndXJhdGlvbiB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBmb2xkZXIsIHZzY29kZVZlcnNpb24sIHZlcnNpb246IGluZm8udmVyc2lvbiB9XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2V2ZXJlU2VydmljZUVycm9yKGBDb3VsZG4ndCBzZXQgdXAgVlNDb2RlIFdlYjogJHtlcnIubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfdXBkYXRlVmVyc2lvbnNUeHQgKFxuICAgICAgICB2ZXJzaW9uOiBzdHJpbmcsXG4gICAgICAgIHZzY29kZVZlcnNpb246IHN0cmluZyxcbiAgICAgICAgY2hyb21lZHJpdmVyVmVyc2lvbjogc3RyaW5nLFxuICAgICAgICB2ZXJzaW9uc0ZpbGVFeGlzdDogYm9vbGVhblxuICAgICkge1xuICAgICAgICBjb25zdCBuZXdDb250ZW50OiBWZXJzaW9ucyA9IHtcbiAgICAgICAgICAgIFt2ZXJzaW9uXToge1xuICAgICAgICAgICAgICAgIGNocm9tZWRyaXZlcjogY2hyb21lZHJpdmVyVmVyc2lvbixcbiAgICAgICAgICAgICAgICB2c2NvZGU6IHZzY29kZVZlcnNpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJzaW9uc1R4dFBhdGggPSBwYXRoLmpvaW4odGhpcy5fY2FjaGVQYXRoLCBWRVJTSU9OU19UWFQpXG4gICAgICAgIGlmICghdmVyc2lvbnNGaWxlRXhpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmcy53cml0ZUZpbGUoXG4gICAgICAgICAgICAgICAgdmVyc2lvbnNUeHRQYXRoLFxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG5ld0NvbnRlbnQsIG51bGwsIDQpLFxuICAgICAgICAgICAgICAgICd1dGYtOCdcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKChhd2FpdCBmcy5yZWFkRmlsZSh2ZXJzaW9uc1R4dFBhdGgsICd1dGYtOCcpKS50b1N0cmluZygpKVxuICAgICAgICByZXR1cm4gZnMud3JpdGVGaWxlKFxuICAgICAgICAgICAgdmVyc2lvbnNUeHRQYXRoLFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyAuLi5jb250ZW50LCAuLi5uZXdDb250ZW50IH0sIG51bGwsIDQpLFxuICAgICAgICAgICAgJ3V0Zi04J1xuICAgICAgICApXG4gICAgfVxufVxuIl19