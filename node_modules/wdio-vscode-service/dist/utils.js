import fs from 'node:fs/promises';
import url from 'node:url';
import path from 'node:path';
import { VSCODE_CAPABILITY_KEY } from './constants.js';
const __dirname = url.fileURLToPath(new URL('.', import.meta.url));
export async function getLocators(version) {
    if (version === 'insiders') {
        return import('./locators/insiders.js');
    }
    const files = (await fs.readdir(path.join(__dirname, 'locators'), { encoding: 'utf-8' }))
        .filter((filename) => filename.endsWith('.js') && !filename.endsWith('.d.ts'))
        .map((filename) => filename.slice(0, -3));
    const [major, minor] = version.split('.');
    const sanitizedVersion = `${major}.${minor}.0`;
    const locatorFile = files.find((f, i) => (f === sanitizedVersion
        || (files[i + 1] && files[i + 1] > sanitizedVersion))) || files[files.length - 1];
    return import(`./locators/${locatorFile}.js`);
}
export function fileExist(filepath) {
    return fs.access(filepath).then(() => true, () => false);
}
export async function directoryExists(directoryPath) {
    try {
        const stats = await fs.stat(directoryPath);
        return stats.isDirectory();
    }
    catch {
        return false;
    }
}
export function getValueSuffix(value) {
    if (typeof value === 'boolean' && value) {
        return '';
    }
    return `=${value}`;
}
export function isVSCodeCapability(cap) {
    return Boolean(cap[VSCODE_CAPABILITY_KEY]);
}
var FileType;
(function (FileType) {
    FileType[FileType["Unknown"] = 0] = "Unknown";
    FileType[FileType["File"] = 1] = "File";
    FileType[FileType["Directory"] = 2] = "Directory";
    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType || (FileType = {}));
export function getFileType(stats) {
    if (stats.isFile()) {
        return FileType.File;
    }
    if (stats.isDirectory()) {
        return FileType.Directory;
    }
    if (stats.isSymbolicLink()) {
        return FileType.SymbolicLink;
    }
    return FileType.Unknown;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sa0JBQWtCLENBQUE7QUFDakMsT0FBTyxHQUFHLE1BQU0sVUFBVSxDQUFBO0FBQzFCLE9BQU8sSUFBSSxNQUFNLFdBQVcsQ0FBQTtBQUc1QixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQTtBQUl0RCxNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsYUFBYSxDQUFDLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUE7QUFFbEUsTUFBTSxDQUFDLEtBQUssVUFBVSxXQUFXLENBQUUsT0FBZTtJQUM5QyxJQUFJLE9BQU8sS0FBSyxVQUFVLEVBQUUsQ0FBQztRQUN6QixPQUFPLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBcUMsQ0FBQTtJQUMvRSxDQUFDO0lBRUQsTUFBTSxLQUFLLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUNwRixNQUFNLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQzdFLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0lBRTdDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQTtJQUN6QyxNQUFNLGdCQUFnQixHQUFHLEdBQUcsS0FBSyxJQUFJLEtBQUssSUFBSSxDQUFBO0lBRTlDLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUNyQyxDQUFDLEtBQUssZ0JBQWdCO1dBQ25CLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLENBQ3ZELENBQUMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQTtJQUM3QixPQUFPLE1BQU0sQ0FBQyxjQUFjLFdBQVcsS0FBSyxDQUE4QixDQUFBO0FBQzlFLENBQUM7QUFFRCxNQUFNLFVBQVUsU0FBUyxDQUFFLFFBQWdCO0lBQ3ZDLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQzVELENBQUM7QUFFRCxNQUFNLENBQUMsS0FBSyxVQUFVLGVBQWUsQ0FBRSxhQUFxQjtJQUN4RCxJQUFJLENBQUM7UUFDRCxNQUFNLEtBQUssR0FBRyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUE7UUFDMUMsT0FBTyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUE7SUFDOUIsQ0FBQztJQUFDLE1BQU0sQ0FBQztRQUNMLE9BQU8sS0FBSyxDQUFBO0lBQ2hCLENBQUM7QUFDTCxDQUFDO0FBRUQsTUFBTSxVQUFVLGNBQWMsQ0FBRSxLQUF1QjtJQUNuRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFNBQVMsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUN0QyxPQUFPLEVBQUUsQ0FBQTtJQUNiLENBQUM7SUFDRCxPQUFPLElBQUksS0FBSyxFQUFFLENBQUE7QUFDdEIsQ0FBQztBQUVELE1BQU0sVUFBVSxrQkFBa0IsQ0FBRSxHQUF1QjtJQUN2RCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFBO0FBQzlDLENBQUM7QUFFRCxJQUFLLFFBS0o7QUFMRCxXQUFLLFFBQVE7SUFDVCw2Q0FBVyxDQUFBO0lBQ1gsdUNBQVEsQ0FBQTtJQUNSLGlEQUFhLENBQUE7SUFDYix3REFBaUIsQ0FBQTtBQUNyQixDQUFDLEVBTEksUUFBUSxLQUFSLFFBQVEsUUFLWjtBQUVELE1BQU0sVUFBVSxXQUFXLENBQUUsS0FBcUI7SUFDOUMsSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQztRQUNqQixPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUE7SUFDeEIsQ0FBQztJQUVELElBQUksS0FBSyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUM7UUFDdEIsT0FBTyxRQUFRLENBQUMsU0FBUyxDQUFBO0lBQzdCLENBQUM7SUFFRCxJQUFJLEtBQUssQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDO1FBQ3pCLE9BQU8sUUFBUSxDQUFDLFlBQVksQ0FBQTtJQUNoQyxDQUFDO0lBRUQsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFBO0FBQzNCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnbm9kZTpmcy9wcm9taXNlcydcbmltcG9ydCB1cmwgZnJvbSAnbm9kZTp1cmwnXG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnXG5pbXBvcnQgdHlwZSB7IERpcmVudCwgU3RhdHMgfSBmcm9tICdub2RlOmZzJ1xuXG5pbXBvcnQgeyBWU0NPREVfQ0FQQUJJTElUWV9LRVkgfSBmcm9tICcuL2NvbnN0YW50cy5qcydcbmltcG9ydCB0eXBlIHsgVlNDb2RlTG9jYXRvck1hcCB9IGZyb20gJy4vcGFnZW9iamVjdHMvdXRpbHMuanMnXG5pbXBvcnQgdHlwZSB7IFZTQ29kZUNhcGFiaWxpdGllcyB9IGZyb20gJy4vdHlwZXMuanMnXG5cbmNvbnN0IF9fZGlybmFtZSA9IHVybC5maWxlVVJMVG9QYXRoKG5ldyBVUkwoJy4nLCBpbXBvcnQubWV0YS51cmwpKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYXRvcnMgKHZlcnNpb246IHN0cmluZyk6IFByb21pc2U8VlNDb2RlTG9jYXRvck1hcD4ge1xuICAgIGlmICh2ZXJzaW9uID09PSAnaW5zaWRlcnMnKSB7XG4gICAgICAgIHJldHVybiBpbXBvcnQoJy4vbG9jYXRvcnMvaW5zaWRlcnMuanMnKSBhcyBhbnkgYXMgUHJvbWlzZTxWU0NvZGVMb2NhdG9yTWFwPlxuICAgIH1cblxuICAgIGNvbnN0IGZpbGVzID0gKGF3YWl0IGZzLnJlYWRkaXIocGF0aC5qb2luKF9fZGlybmFtZSwgJ2xvY2F0b3JzJyksIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSkpXG4gICAgICAgIC5maWx0ZXIoKGZpbGVuYW1lKSA9PiBmaWxlbmFtZS5lbmRzV2l0aCgnLmpzJykgJiYgIWZpbGVuYW1lLmVuZHNXaXRoKCcuZC50cycpKVxuICAgICAgICAubWFwKChmaWxlbmFtZSkgPT4gZmlsZW5hbWUuc2xpY2UoMCwgLTMpKVxuXG4gICAgY29uc3QgW21ham9yLCBtaW5vcl0gPSB2ZXJzaW9uLnNwbGl0KCcuJylcbiAgICBjb25zdCBzYW5pdGl6ZWRWZXJzaW9uID0gYCR7bWFqb3J9LiR7bWlub3J9LjBgXG5cbiAgICBjb25zdCBsb2NhdG9yRmlsZSA9IGZpbGVzLmZpbmQoKGYsIGkpID0+IChcbiAgICAgICAgZiA9PT0gc2FuaXRpemVkVmVyc2lvblxuICAgICAgICB8fCAoZmlsZXNbaSArIDFdICYmIGZpbGVzW2kgKyAxXSA+IHNhbml0aXplZFZlcnNpb24pXG4gICAgKSkgfHwgZmlsZXNbZmlsZXMubGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gaW1wb3J0KGAuL2xvY2F0b3JzLyR7bG9jYXRvckZpbGV9LmpzYCkgYXMgUHJvbWlzZTxWU0NvZGVMb2NhdG9yTWFwPlxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsZUV4aXN0IChmaWxlcGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZzLmFjY2VzcyhmaWxlcGF0aCkudGhlbigoKSA9PiB0cnVlLCAoKSA9PiBmYWxzZSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRpcmVjdG9yeUV4aXN0cyAoZGlyZWN0b3J5UGF0aDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmcy5zdGF0KGRpcmVjdG9yeVBhdGgpXG4gICAgICAgIHJldHVybiBzdGF0cy5pc0RpcmVjdG9yeSgpXG4gICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlU3VmZml4ICh2YWx1ZTogc3RyaW5nIHwgYm9vbGVhbikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJydcbiAgICB9XG4gICAgcmV0dXJuIGA9JHt2YWx1ZX1gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZTQ29kZUNhcGFiaWxpdHkgKGNhcDogVlNDb2RlQ2FwYWJpbGl0aWVzKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0pXG59XG5cbmVudW0gRmlsZVR5cGUge1xuICAgIFVua25vd24gPSAwLFxuICAgIEZpbGUgPSAxLFxuICAgIERpcmVjdG9yeSA9IDIsXG4gICAgU3ltYm9saWNMaW5rID0gNjRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVUeXBlIChzdGF0czogU3RhdHMgfCBEaXJlbnQpIHtcbiAgICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgICAgcmV0dXJuIEZpbGVUeXBlLkZpbGVcbiAgICB9XG5cbiAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICByZXR1cm4gRmlsZVR5cGUuRGlyZWN0b3J5XG4gICAgfVxuXG4gICAgaWYgKHN0YXRzLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgcmV0dXJuIEZpbGVUeXBlLlN5bWJvbGljTGlua1xuICAgIH1cblxuICAgIHJldHVybiBGaWxlVHlwZS5Vbmtub3duXG59XG4iXX0=