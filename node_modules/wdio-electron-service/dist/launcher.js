var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ElectronLaunchService_globalOptions, _ElectronLaunchService_projectRoot;
import util from 'node:util';
import findVersions from 'find-versions';
import { readPackageUp } from 'read-package-up';
import { SevereServiceError } from 'webdriverio';
import log from './log.js';
import { getBinaryPath, getAppBuildInfo } from './application.js';
import { getChromeOptions, getChromedriverOptions, getElectronCapabilities } from './capabilities.js';
import { getChromiumVersion } from './versions.js';
import { APP_NOT_FOUND_ERROR, CUSTOM_CAPABILITY_NAME } from './constants.js';
class ElectronLaunchService {
    constructor(globalOptions, _caps, config) {
        _ElectronLaunchService_globalOptions.set(this, void 0);
        _ElectronLaunchService_projectRoot.set(this, void 0);
        __classPrivateFieldSet(this, _ElectronLaunchService_globalOptions, globalOptions, "f");
        __classPrivateFieldSet(this, _ElectronLaunchService_projectRoot, config.rootDir || process.cwd(), "f");
    }
    async onPrepare(_config, capabilities) {
        const capsList = Array.isArray(capabilities)
            ? capabilities
            : Object.values(capabilities).map((multiremoteOption) => multiremoteOption.capabilities);
        const caps = capsList.flatMap((cap) => getElectronCapabilities(cap));
        const pkg = (await readPackageUp({ cwd: __classPrivateFieldGet(this, _ElectronLaunchService_projectRoot, "f") })) ||
            { packageJson: { dependencies: {}, devDependencies: {} } };
        const { dependencies, devDependencies } = pkg.packageJson;
        const pkgElectronVersion = dependencies?.electron ||
            devDependencies?.electron ||
            dependencies?.['electron-nightly'] ||
            devDependencies?.['electron-nightly'];
        const localElectronVersion = pkgElectronVersion ? findVersions(pkgElectronVersion, { loose: true })[0] : undefined;
        if (!caps.length) {
            const noElectronCapabilityError = new Error('No Electron browser found in capabilities');
            log.error(noElectronCapabilityError);
            throw noElectronCapabilityError;
        }
        await Promise.all(caps.map(async (cap) => {
            const electronVersion = cap.browserVersion || localElectronVersion;
            const chromiumVersion = await getChromiumVersion(electronVersion);
            log.debug(`Found Electron v${electronVersion} with Chromedriver v${chromiumVersion}`);
            let { appBinaryPath, appArgs } = Object.assign({}, __classPrivateFieldGet(this, _ElectronLaunchService_globalOptions, "f"), cap[CUSTOM_CAPABILITY_NAME]);
            if (!appBinaryPath) {
                log.debug('No app binary found');
                try {
                    const appBuildInfo = await getAppBuildInfo(pkg);
                    try {
                        appBinaryPath = await getBinaryPath(pkg.path, appBuildInfo, electronVersion);
                        log.debug(`Detected app binary at ${appBinaryPath}`);
                    }
                    catch (e) {
                        const buildToolName = appBuildInfo.isForge ? 'Electron Forge' : 'electron-builder';
                        const suggestedCompileCommand = `npx ${appBuildInfo.isForge ? 'electron-forge make' : 'electron-builder build'}`;
                        throw new Error(util.format(APP_NOT_FOUND_ERROR, appBinaryPath, buildToolName, suggestedCompileCommand));
                    }
                }
                catch (e) {
                    log.error(e);
                    throw new SevereServiceError(e.message);
                }
            }
            cap.browserName = 'chrome';
            cap['goog:chromeOptions'] = getChromeOptions({ appBinaryPath, appArgs }, cap);
            const chromedriverOptions = getChromedriverOptions(cap);
            if (!chromiumVersion && Object.keys(chromedriverOptions).length > 0) {
                cap['wdio:chromedriverOptions'] = chromedriverOptions;
            }
            const browserVersion = chromiumVersion || cap.browserVersion;
            if (browserVersion) {
                cap.browserVersion = browserVersion;
            }
            else if (!cap['wdio:chromedriverOptions']?.binary) {
                const invalidBrowserVersionOptsError = new Error('You must install Electron locally, or provide a custom Chromedriver path / browserVersion value for each Electron capability');
                log.error(invalidBrowserVersionOptsError);
                throw invalidBrowserVersionOptsError;
            }
            /**
             * attach custom capability to be able to identify Electron instances
             * in the worker process
             */
            cap[CUSTOM_CAPABILITY_NAME] = cap[CUSTOM_CAPABILITY_NAME] || {};
            log.debug('setting capability', cap);
        })).catch((err) => {
            const msg = `Failed setting up Electron session: ${err.stack}`;
            log.error(msg);
            throw new SevereServiceError(msg);
        });
    }
}
_ElectronLaunchService_globalOptions = new WeakMap(), _ElectronLaunchService_projectRoot = new WeakMap();
export default ElectronLaunchService;
//# sourceMappingURL=launcher.js.map