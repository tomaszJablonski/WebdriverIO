{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"AAmMA,IAAK,sBAGJ;AAHD,WAAK,sBAAsB;IACzB,2CAAiB,CAAA;IACjB,yCAAe,CAAA;AACjB,CAAC,EAHI,sBAAsB,KAAtB,sBAAsB,QAG1B","sourcesContent":["import type * as Electron from 'electron';\nimport type { Mock } from '@vitest/spy';\nimport type { OfficialArch } from '@electron/packager';\nimport type { ForgeConfig as ElectronForgeConfig } from '@electron-forge/shared-types';\nimport type { ArchType } from 'builder-util';\n\nexport type Fn = (...args: unknown[]) => unknown;\nexport type AsyncFn = (...args: unknown[]) => Promise<unknown>;\nexport type AbstractFn = Fn | AsyncFn;\nexport type ElectronApiFn = ElectronType[ElectronInterface][keyof ElectronType[ElectronInterface]];\n\nexport interface ElectronServiceAPI {\n  /**\n   * Mock a function from the Electron API.\n   *\n   * @param apiName name of the API to mock\n   * @param funcName name of the function to mock\n   * @param mockReturnValue value to return when the mocked function is called\n   * @returns a {@link Promise} that resolves once the mock is registered\n   *\n   * @example\n   * ```js\n   * // mock the dialog API showOpenDialog method\n   * const showOpenDialog = await browser.electron.mock('dialog', 'showOpenDialog');\n   * await browser.electron.execute(\n   *   async (electron) =>\n   *     await electron.dialog.showOpenDialog({\n   *       properties: ['openFile', 'openDirectory'],\n   *     }),\n   * );\n   *\n   * expect(showOpenDialog).toHaveBeenCalledTimes(1);\n   * expect(showOpenDialog).toHaveBeenCalledWith({\n   *   properties: ['openFile', 'openDirectory'],\n   * });\n   * ```\n   */\n  mock: <Interface extends ElectronInterface>(\n    apiName: Interface,\n    funcName?: string,\n    returnValue?: unknown,\n  ) => Promise<ElectronMock>;\n  /**\n   * Mock all functions from an Electron API.\n   *\n   * @param apiName name of the API to mock\n   * @returns a {@link Promise} that resolves once the mock is registered\n   *\n   * @example\n   * ```js\n   * // mock multiple functions from the app API\n   * const app = await browser.electron.mockAll('app');\n   * await app.getName.mockReturnValue('mocked-app');\n   * await app.getVersion.mockReturnValue('1.0.0-mocked.12');\n   * const result = await browser.electron.execute((electron) => `${electron.app.getName()}::${electron.app.getVersion()}`);\n   * expect(result).toEqual('mocked-app::1.0.0-mocked.12');\n   * ```\n   */\n  mockAll: <Interface extends ElectronInterface>(apiName: Interface) => Promise<Record<string, ElectronMock>>;\n  /**\n   * Execute a function within the Electron main process.\n   *\n   * @example\n   * ```js\n   * await browser.electron.execute((electron, param1, param2, param3) => {\n   *   const appWindow = electron.BrowserWindow.getFocusedWindow();\n   *   electron.dialog.showMessageBox(appWindow, {\n   *     message: 'Hello World!',\n   *     detail: `${param1} + ${param2} + ${param3} = ${param1 + param2 + param3}`\n   *   });\n   * }, 1, 2, 3)\n   * ```\n   *\n   * @param script function to execute\n   * @param args function arguments\n   */\n  execute<ReturnValue, InnerArguments extends unknown[]>(\n    script: string | ((electron: typeof Electron, ...innerArgs: InnerArguments) => ReturnValue),\n    ...args: InnerArguments\n  ): Promise<ReturnValue>;\n  /**\n   * Clear mocked Electron API function(s).\n   *\n   * @example\n   * ```js\n   * // clears all mocked functions\n   * await browser.electron.clearAllMocks()\n   * // clears all mocked functions of dialog API\n   * await browser.electron.clearAllMocks('dialog')\n   * ```\n   *\n   * @param apiName mocked api to clear\n   */\n  clearAllMocks: (apiName?: string) => Promise<void>;\n  /**\n   * Reset mocked Electron API function(s).\n   *\n   * @example\n   * ```js\n   * // resets all mocked functions\n   * await browser.electron.resetAllMocks()\n   * // resets all mocked functions of dialog API\n   * await browser.electron.resetAllMocks('dialog')\n   * ```\n   *\n   * @param apiName mocked api to reset\n   */\n  resetAllMocks: (apiName?: string) => Promise<void>;\n  /**\n   * Restore mocked Electron API function(s).\n   *\n   * @example\n   * ```js\n   * // restores all mocked functions\n   * await browser.electron.restoreAllMocks()\n   * // restores all mocked functions of dialog API\n   * await browser.electron.restoreAllMocks('dialog')\n   * ```\n   *\n   * @param apiName mocked api to remove\n   */\n  restoreAllMocks: (apiName?: string) => Promise<void>;\n  /**\n   * Checks that a given parameter is an Electron mock function. If you are using TypeScript, it will also narrow down its type.\n   *\n   * @example\n   * ```js\n   * const mockGetName = await browser.electron.mock('app', 'getName');\n   *\n   * expect(browser.electron.isMockFunction(mockGetName)).toBe(true);\n   * ```\n   */\n  isMockFunction: (fn: unknown) => fn is ElectronMockInstance;\n}\n\n/**\n * The options for the Electron Service.\n */\nexport interface ElectronServiceOptions {\n  /**\n   * The path to the electron binary of the app for testing.\n   */\n  appBinaryPath?: string;\n  /**\n   * An array of string arguments to be passed through to the app on execution of the test run.\n   * Electron [command line switches](https://www.electronjs.org/docs/latest/api/command-line-switches)\n   * and some [Chromium switches](https://peter.sh/experiments/chromium-command-line-switches) can be\n   * used here.\n   */\n  appArgs?: string[];\n  /**\n   * Calls .mockClear() on all mocked APIs before each test. This will clear mock history, but not reset its implementation.\n   */\n  clearMocks?: boolean;\n  /**\n   * Calls .mockReset() on all mocked APIs before each test. This will clear mock history and reset its implementation to an empty function (will return undefined).\n   */\n  resetMocks?: boolean;\n  /**\n   * Calls .mockRestore() on all mocked APIs before each test. This will restore the original API function, the mock will be removed.\n   */\n  restoreMocks?: boolean;\n}\n\nexport type ApiCommand = { name: string; bridgeProp: string };\nexport type WebdriverClientFunc = (this: WebdriverIO.Browser, ...args: unknown[]) => Promise<unknown>;\n\nexport type ElectronType = typeof Electron;\nexport type ElectronInterface = keyof ElectronType;\n\nexport type BuilderConfig = {\n  productName?: string;\n  directories?: { output?: string };\n};\n\nexport type ForgeConfig = ElectronForgeConfig;\n\nexport type BuilderArch = ArchType;\nexport type ForgeArch = OfficialArch;\n\nexport type AppBuildInfo = {\n  appName: string;\n  config: string | ForgeConfig | BuilderConfig;\n  isBuilder: boolean;\n  isForge: boolean;\n};\n\nexport type ExecuteOpts = {\n  internal?: boolean;\n};\n\nexport type WdioElectronWindowObj = {\n  execute: (script: string, args?: unknown[]) => unknown;\n};\n\nenum ElectronMockResultType {\n  Return = 'return',\n  Throw = 'throw',\n}\n\ntype ElectronMockResult = {\n  type: ElectronMockResultType;\n  value: unknown;\n};\n\ninterface ElectronMockContext {\n  /**\n   * This is an array containing all arguments for each call. Each item of the array is the arguments of that call.\n   *\n   * @example\n   * ```js\n   * const mockGetFileIcon = await browser.electron.mock('app', 'getFileIcon');\n   *\n   * await browser.electron.execute((electron) => electron.app.getFileIcon('/path/to/icon'));\n   * await browser.electron.execute((electron) => electron.app.getFileIcon('/path/to/another/icon', { size: 'small' }));\n   *\n   * expect(mockGetFileIcon.mock.calls).toStrictEqual([\n   *   ['/path/to/icon'], // first call\n   *   ['/path/to/another/icon', { size: 'small' }], // second call\n   * ]);\n   * ```\n   */\n  calls: unknown[][];\n  /**\n   * The order of mock invocation. This returns an array of numbers that are shared between all defined mocks. Will return an empty array if the mock was never invoked.\n   *\n   * @example\n   * ```js\n   * const mockGetName = await browser.electron.mock('app', 'getName');\n   * const mockGetVersion = await browser.electron.mock('app', 'getVersion');\n   *\n   * await browser.electron.execute((electron) => electron.app.getName());\n   * await browser.electron.execute((electron) => electron.app.getVersion());\n   * await browser.electron.execute((electron) => electron.app.getName());\n   *\n   * expect(mockGetName.mock.invocationCallOrder).toStrictEqual([1, 3]);\n   * expect(mockGetVersion.mock.invocationCallOrder).toStrictEqual([2]);\n   * ```\n   */\n  invocationCallOrder: number[];\n  /**\n   * This is an array containing all values that were returned from the mock. Each item of the array is an object with the properties type and value. Available types are:\n   *\n   *     'return' - the mock returned without throwing.\n   *     'throw' - the mock threw a value.\n   *\n   * The value property contains the returned value or the thrown error. If the mock returned a promise, the value will be the resolved value, not the Promise itself, unless it was never resolved.\n   *\n   * @example\n   * ```js\n   * const mockGetName = await browser.electron.mock('app', 'getName');\n   *\n   * await mockGetName.mockImplementationOnce(() => 'result');\n   * await mockGetName.mockImplementation(() => {\n   *   throw new Error('thrown error');\n   * });\n   *\n   * await expect(browser.electron.execute((electron) => electron.app.getName())).resolves.toBe('result');\n   * await expect(browser.electron.execute((electron) => electron.app.getName())).rejects.toThrow('thrown error');\n   *\n   * expect(mockGetName.mock.results).toStrictEqual([\n   *   {\n   *     type: 'return',\n   *     value: 'result',\n   *   },\n   *   {\n   *     type: 'throw',\n   *     value: new Error('thrown error'),\n   *   },\n   * ]);\n   * ```\n   */\n  results: ElectronMockResult[];\n  /**\n   * This contains the arguments of the last call. If the mock wasn't called, it will return `undefined`.\n   *\n   * @example\n   * ```js\n   * const mockSetName = await browser.electron.mock('app', 'setName');\n   *\n   * await browser.electron.execute((electron) => electron.app.setName('test'));\n   * expect(mockSetName.mock.lastCall).toStrictEqual(['test']);\n   * await browser.electron.execute((electron) => electron.app.setName('test 2'));\n   * expect(mockSetName.mock.lastCall).toStrictEqual(['test 2']);\n   * await browser.electron.execute((electron) => electron.app.setName('test 3'));\n   * expect(mockSetName.mock.lastCall).toStrictEqual(['test 3']);\n   * ```\n   */\n  lastCall: unknown;\n}\n\ntype Override =\n  | 'mockImplementation'\n  | 'mockImplementationOnce'\n  | 'mockReturnValue'\n  | 'mockReturnValueOnce'\n  | 'mockResolvedValue'\n  | 'mockResolvedValueOnce'\n  | 'mockRejectedValue'\n  | 'mockRejectedValueOnce'\n  | 'mockClear'\n  | 'mockReset'\n  | 'mockReturnThis'\n  | 'mockName'\n  | 'withImplementation'\n  | 'mock';\n\nexport interface ElectronMockInstance extends Omit<Mock, Override> {\n  /**\n   * Accepts a function that will be used as an implementation of the mock.\n   *\n   * @example\n   * ```js\n   * const mockGetName = await browser.electron.mock('app', 'getName');\n   * let callsCount = 0;\n   * await mockGetName.mockImplementation(() => {\n   *   // callsCount is not accessible in the electron context so we need to guard it\n   *   if (typeof callsCount !== 'undefined') {\n   *     callsCount++;\n   *   }\n   *   return 'mocked value';\n   * });\n   *\n   * const name = await browser.electron.execute(async (electron) => await electron.app.getName());\n   * expect(callsCount).toBe(1);\n   * expect(name).toBe('mocked value');\n   * ```\n   */\n  mockImplementation(fn: AbstractFn): Promise<ElectronMock>;\n  /**\n   * Accepts a function that will be used as the mock's implementation during the next call. If chained, every consecutive call will produce different results.\n   *\n   * When the mocked function runs out of implementations, it will invoke the default implementation set with `mockImplementation`.\n   *\n   * @example\n   * ```js\n   *  const mockGetName = await browser.electron.mock('app', 'getName');\n   *  await mockGetName.mockImplementation(() => 'default mock');\n   *  await mockGetName.mockImplementationOnce(() => 'first mock');\n   *  await mockGetName.mockImplementationOnce(() => 'second mock');\n   *\n   *  let name = await browser.electron.execute((electron) => electron.app.getName());\n   *  expect(name).toBe('first mock');\n   *  name = await browser.electron.execute((electron) => electron.app.getName());\n   *  expect(name).toBe('second mock');\n   *  name = await browser.electron.execute((electron) => electron.app.getName());\n   *  expect(name).toBe('default mock');\n   * ```\n   */\n  mockImplementationOnce(fn: AbstractFn): Promise<ElectronMock>;\n  /**\n   * Accepts a value that will be returned whenever the mock function is called.\n   *\n   * @example\n   * ```js\n   *  const mockGetName = await browser.electron.mock('app', 'getName');\n   *  await mockGetName.mockReturnValue('mocked name');\n   *\n   *  const name = await browser.electron.execute((electron) => electron.app.getName());\n   *  expect(name).toBe('mocked name');\n   * ```\n   */\n  mockReturnValue(obj: unknown): Promise<ElectronMock>;\n  /**\n   * Accepts a value that will be returned during the next function call. If chained, every consecutive call will return the specified value.\n   *\n   * When there are no more `mockReturnValueOnce` values to use, the mock will fall back to the previously defined implementation if there is one.\n   *\n   * @example\n   * ```js\n   *  const mockGetName = await browser.electron.mock('app', 'getName')\n   *  await mockGetName.mockReturnValue('default mock');\n   *  await mockGetName.mockReturnValueOnce('first mock');\n   *  await mockGetName.mockReturnValueOnce('second mock');\n   *\n   *  let name = await browser.electron.execute((electron) => electron.app.getName());\n   *  expect(name).toBe('first mock');\n   *  name = await browser.electron.execute((electron) => electron.app.getName());\n   *  expect(name).toBe('second mock');\n   *  name = await browser.electron.execute((electron) => electron.app.getName());\n   *  expect(name).toBe('default mock');\n   * ```\n   */\n  mockReturnValueOnce(obj: unknown): Promise<ElectronMock>;\n  /**\n   * Accepts a value that will be resolved when an async function is called.\n   *\n   * @example\n   * ```js\n   *  const mockGetFileIcon = await browser.electron.mock('app', 'getFileIcon');\n   *  await mockGetFileIcon.mockResolvedValue('This is a mock');\n   *\n   *  const fileIcon = await browser.electron.execute(\n   *    async (electron) => await electron.app.getFileIcon('/path/to/icon'),\n   *  );\n   *\n   *  expect(fileIcon).toBe('This is a mock');\n   * ```\n   */\n  mockResolvedValue(obj: unknown): Promise<ElectronMock>;\n  /**\n   * Accepts a value that will be resolved during the next function call. If chained, every consecutive call will resolve the specified value.\n   *\n   * @example\n   * ```js\n   *  const mockGetFileIcon = await browser.electron.mock('app', 'getFileIcon');\n   *  await mockGetFileIcon.mockResolvedValue('default mock')\n   *  await mockGetFileIcon.mockResolvedValueOnce('first mock');\n   *  await mockGetFileIcon.mockResolvedValueOnce('second mock');\n   *\n   *  let fileIcon = await browser.electron.execute(\n   *    async (electron) => await electron.app.getFileIcon('/path/to/icon'),\n   *  );\n   *  expect(fileIcon).toBe('first mock');\n   *  fileIcon = await browser.electron.execute(\n   *    async (electron) => await electron.app.getFileIcon('/path/to/icon'),\n   *  );\n   *  expect(fileIcon).toBe('second mock');\n   *  fileIcon = await browser.electron.execute(\n   *    async (electron) => await electron.app.getFileIcon('/path/to/icon'),\n   *  );\n   *  expect(fileIcon).toBe('default mock');\n   * ```\n   */\n  mockResolvedValueOnce(obj: unknown): Promise<ElectronMock>;\n  /**\n   * Accepts a value that will be rejected when an async function is called.\n   *\n   * @example\n   * ```js\n   *  const mockGetFileIcon = await browser.electron.mock('app', 'getFileIcon');\n   *  await mockGetFileIcon.mockRejectedValue('This is a mock error');\n   *\n   *  const fileIconError = await browser.electron.execute(async (electron) => {\n   *    try {\n   *      await electron.app.getFileIcon('/path/to/icon');\n   *    } catch (e) {\n   *      return e;\n   *    }\n   *  });\n   *\n   *  expect(fileIconError).toBe('This is a mock error');\n   * ```\n   */\n  mockRejectedValue(obj: unknown): Promise<ElectronMock>;\n  /**\n   * Accepts a value that will be rejected during the next function call. If chained, every consecutive call will resolve the specified value.\n   *\n   * @example\n   * ```js\n   *  const mockGetFileIcon = await browser.electron.mock('app', 'getFileIcon');\n   *  await mockGetFileIcon.mockRejectedValue('default mocked icon error')\n   *  await mockGetFileIcon.mockRejectedValueOnce('first mocked icon error');\n   *  await mockGetFileIcon.mockRejectedValueOnce('second mocked icon error');\n   *\n   *  const getFileIcon = async () =>\n   *    await browser.electron.execute(async (electron) => {\n   *      try {\n   *        await electron.app.getFileIcon('/path/to/icon');\n   *      } catch (e) {\n   *        return e;\n   *      }\n   *    });\n   *\n   *  let fileIcon = await getFileIcon();\n   *  expect(fileIcon).toBe('first mocked icon error');\n   *  fileIcon = await getFileIcon();\n   *  expect(fileIcon).toBe('second mocked icon error');\n   *  fileIcon = await getFileIcon();\n   *  expect(fileIcon).toBe('default mocked icon error');\n   * ```\n   */\n  mockRejectedValueOnce(obj: unknown): Promise<ElectronMock>;\n  /**\n   * Clears the history of the mocked Electron API function. The mock implementation will not be reset.\n   *\n   * @example\n   * ```js\n   *  const mockGetName = await browser.electron.mock('app', 'getName');\n   *  await browser.electron.execute((electron) => electron.app.getName());\n   *\n   *  await mockGetName.mockClear();\n   *\n   *  await browser.electron.execute((electron) => electron.app.getName());\n   *  expect(mockGetName).toHaveBeenCalledTimes(1);\n   * ```\n   */\n  mockClear(): Promise<ElectronMock>;\n  /**\n   * Resets the mocked Electron API function. The mock history will be cleared and the implementation will be reset to an empty function (returning `undefined`).\n   *\n   * This also resets all \"once\" implementations.\n   *\n   * @example\n   * ```js\n   *  const mockGetName = await browser.electron.mock('app', 'getName');\n   *  await mockGetName.mockReturnValue('mocked name');\n   *  await browser.electron.execute((electron) => electron.app.getName());\n   *\n   *  await mockGetName.mockReset();\n   *\n   *  const name = await browser.electron.execute((electron) => electron.app.getName());\n   *  expect(name).toBeUndefined();\n   *  expect(mockGetName).toHaveBeenCalledTimes(1);\n   * ```\n   */\n  mockReset(): Promise<ElectronMock>;\n  /**\n   * Restores the original implementation to the Electron API function.\n   *\n   * @example\n   * ```js\n   *  const appName = await browser.electron.execute((electron) => electron.app.getName());\n   *  const mockGetName = await browser.electron.mock('app', 'getName');\n   *  await mockGetName.mockReturnValue('mocked name');\n   *\n   *  await mockGetName.mockRestore();\n   *\n   *  const name = await browser.electron.execute((electron) => electron.app.getName());\n   *  expect(name).toBe(appName);\n   * ```\n   */\n  mockRestore(): Promise<ElectronMock>;\n  /**\n   * Useful if you need to return the `this` context from the method without invoking implementation. This is a shorthand for:\n   *\n   * ```js\n   *  await spy.mockImplementation(function () {\n   *    return this;\n   *  });\n   * ```\n   *\n   * ...which enables API functions to be chained:\n   *\n   * @example\n   * ```js\n   *  const mockGetName = await browser.electron.mock('app', 'getName');\n   *  const mockGetVersion = await browser.electron.mock('app', 'getVersion');\n   *  await mockGetName.mockReturnThis();\n   *  await browser.electron.execute((electron) =>\n   *    electron.app.getName().getVersion()\n   *  );\n   *\n   *  expect(mockGetVersion).toHaveBeenCalled();\n   * ```\n   */\n  mockReturnThis(): Promise<unknown>;\n  /**\n   * Overrides the original mock implementation temporarily while the callback is being executed.\n   * The electron object is passed into the callback in the same way as for `execute`.\n   *\n   * @example\n   * ```js\n   *  const mockGetName = await browser.electron.mock('app', 'getName');\n   *  const withImplementationResult = await mockGetName.withImplementation(\n   *    () => 'temporary mock name',\n   *    (electron) => electron.app.getName(),\n   *  );\n   *\n   *  expect(withImplementationResult).toBe('temporary mock name');\n   * ```\n   *\n   * It can also be used with an asynchronous callback:\n   *\n   * @example\n   * ```js\n   *  const mockGetFileIcon = await browser.electron.mock('app', 'getFileIcon');\n   *  const withImplementationResult = await mockGetFileIcon.withImplementation(\n   *    () => Promise.resolve('temporary mock icon'),\n   *    async (electron) => await electron.app.getFileIcon('/path/to/icon'),\n   *  );\n   *\n   *  expect(withImplementationResult).toBe('temporary mock icon');\n   * ```\n   *\n   */\n  withImplementation<ReturnValue, InnerArguments extends unknown[]>(\n    implFn: AbstractFn,\n    callbackFn: (electron: typeof Electron, ...innerArgs: InnerArguments) => ReturnValue,\n  ): Promise<unknown>;\n  /**\n   * Assigns a name to the mock. Useful to see the name of the mock if an assertion fails.\n   * The name can be retrieved via `getMockName`.\n   *\n   * @example\n   * ```js\n   * const mockGetName = await browser.electron.mock('app', 'getName');\n   * mockGetName.mockName('test mock');\n   *\n   * expect(mockGetName.getMockName()).toBe('test mock');\n   * ```\n   */\n  mockName(name: string): ElectronMock;\n  /**\n   * Returns the assigned name of the mock. Defaults to `electron.<apiName>.<funcName>`.\n   *\n   * @example\n   * ```js\n   * const mockGetName = await browser.electron.mock('app', 'getName');\n   *\n   * expect(mockGetName.getMockName()).toBe('electron.app.getName');\n   * ```\n   */\n  getMockName(): string;\n  /**\n   * Returns the current mock implementation.  The default implementation is an empty function (returns `undefined`).\n   *\n   * @example\n   * ```js\n   *  const mockGetName = await browser.electron.mock('app', 'getName');\n   *  await mockGetName.mockImplementation(() => 'mocked name');\n   *  const mockImpl = mockGetName.getMockImplementation();\n   *\n   *  expect(mockImpl()).toBe('mocked name');\n   * ```\n   */\n  getMockImplementation(): AbstractFn;\n  /**\n   * Used internally to update the outer mock function with calls from the inner (Electron context) mock.\n   *\n   * @private\n   */\n  update(): Promise<ElectronMock>;\n  /**\n   * Current context of the mock. It stores information about all invocation calls and results.\n   */\n  mock: ElectronMockContext;\n  /**\n   * Used internally to distinguish the electron mock from other mocks.\n   *\n   * @private\n   */\n  __isElectronMock: boolean;\n}\n\nexport interface ElectronMock<TArgs extends any[] = any, TReturns = any> extends ElectronMockInstance {\n  new (...args: TArgs): TReturns;\n  (...args: TArgs): TReturns;\n}\n"]}