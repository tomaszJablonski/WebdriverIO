import { fn as vitestFn } from '@vitest/spy';
async function restoreElectronFunctionality(apiName, funcName) {
    await browser.electron.execute((electron, apiName, funcName) => {
        const electronApi = electron[apiName];
        const originalApi = globalThis.originalApi;
        const originalApiMethod = originalApi[apiName][funcName];
        electronApi[funcName].mockImplementation(originalApiMethod);
    }, apiName, funcName, { internal: true });
}
export async function createMock(apiName, funcName) {
    const outerMock = vitestFn();
    const outerMockImplementation = outerMock.mockImplementation;
    const outerMockImplementationOnce = outerMock.mockImplementationOnce;
    const outerMockClear = outerMock.mockClear;
    const outerMockReset = outerMock.mockReset;
    outerMock.mockName(`electron.${apiName}.${funcName}`);
    const mock = outerMock;
    mock.__isElectronMock = true;
    // initialise inner (Electron) mock
    await browser.electron.execute(async (electron, apiName, funcName) => {
        const electronApi = electron[apiName];
        const spy = await import('@vitest/spy');
        const mockFn = spy.fn();
        // replace target API with mock
        electronApi[funcName] = mockFn;
    }, apiName, funcName, { internal: true });
    mock.update = async () => {
        // synchronises inner and outer mocks
        const calls = await browser.electron.execute((electron, apiName, funcName) => {
            const mockObj = electron[apiName][funcName];
            return mockObj.mock?.calls || [];
        }, apiName, funcName, { internal: true });
        // re-apply calls from the electron main process mock to the outer one
        if (mock.mock.calls.length < calls.length) {
            calls.forEach((call, index) => {
                if (!mock.mock.calls[index]) {
                    mock?.apply(mock, call);
                }
            });
        }
        return mock;
    };
    mock.mockImplementation = async (implFn) => {
        await browser.electron.execute((electron, apiName, funcName, mockImplementationStr) => {
            const electronApi = electron[apiName];
            const mockImpl = eval?.(`"use strict"; ${mockImplementationStr}`);
            electronApi[funcName].mockImplementation(mockImpl);
        }, apiName, funcName, implFn.toString(), { internal: true });
        outerMockImplementation(implFn);
        return mock;
    };
    mock.mockImplementationOnce = async (implFn) => {
        await browser.electron.execute((electron, apiName, funcName, mockImplementationStr) => {
            const electronApi = electron[apiName];
            const mockImpl = eval?.(`"use strict"; ${mockImplementationStr}`);
            electronApi[funcName].mockImplementationOnce(mockImpl);
        }, apiName, funcName, implFn.toString(), { internal: true });
        outerMockImplementationOnce(implFn);
        return mock;
    };
    mock.mockReturnValue = async (value) => {
        await browser.electron.execute((electron, apiName, funcName, returnValue) => {
            const electronApi = electron[apiName];
            electronApi[funcName].mockReturnValue(returnValue);
        }, apiName, funcName, value, { internal: true });
        return mock;
    };
    mock.mockReturnValueOnce = async (value) => {
        await browser.electron.execute((electron, apiName, funcName, returnValue) => {
            const electronApi = electron[apiName];
            electronApi[funcName].mockReturnValueOnce(returnValue);
        }, apiName, funcName, value, { internal: true });
        return mock;
    };
    mock.mockResolvedValue = async (value) => {
        await browser.electron.execute((electron, apiName, funcName, resolvedValue) => {
            const electronApi = electron[apiName];
            electronApi[funcName].mockResolvedValue(resolvedValue);
        }, apiName, funcName, value, { internal: true });
        return mock;
    };
    mock.mockResolvedValueOnce = async (value) => {
        await browser.electron.execute((electron, apiName, funcName, resolvedValue) => {
            const electronApi = electron[apiName];
            electronApi[funcName].mockResolvedValueOnce(resolvedValue);
        }, apiName, funcName, value, { internal: true });
        return mock;
    };
    mock.mockRejectedValue = async (value) => {
        await browser.electron.execute((electron, apiName, funcName, rejectedValue) => {
            const electronApi = electron[apiName];
            electronApi[funcName].mockRejectedValue(rejectedValue);
        }, apiName, funcName, value, { internal: true });
        return mock;
    };
    mock.mockRejectedValueOnce = async (value) => {
        await browser.electron.execute((electron, apiName, funcName, rejectedValue) => {
            const electronApi = electron[apiName];
            electronApi[funcName].mockRejectedValueOnce(rejectedValue);
        }, apiName, funcName, value, { internal: true });
        return mock;
    };
    mock.mockClear = async () => {
        // clears mock history
        await browser.electron.execute((electron, apiName, funcName) => {
            electron[apiName][funcName].mockClear();
        }, apiName, funcName, { internal: true });
        outerMockClear();
        return mock;
    };
    mock.mockReset = async () => {
        // resets inner implementation to an empty function and clears mock history
        await browser.electron.execute((electron, apiName, funcName) => {
            electron[apiName][funcName].mockReset();
        }, apiName, funcName, { internal: true });
        outerMockReset();
        // vitest mockReset doesn't clear mock history so we need to explicitly clear both mocks
        await mock.mockClear();
        return mock;
    };
    mock.mockRestore = async () => {
        // restores inner mock implementation to the original function
        await restoreElectronFunctionality(apiName, funcName);
        // clear mocks
        outerMockClear();
        await mock.mockClear();
        return mock;
    };
    mock.mockReturnThis = async () => {
        return await browser.electron.execute((electron, apiName, funcName) => {
            electron[apiName][funcName].mockReturnThis();
        }, apiName, funcName, { internal: true });
    };
    mock.withImplementation = async (implFn, callbackFn) => {
        return await browser.electron.execute(async (electron, apiName, funcName, implFnStr, callbackFnStr) => {
            const callback = eval?.(`"use strict"; ${callbackFnStr}`);
            const impl = eval?.(`"use strict"; ${implFnStr}`);
            let result;
            electron[apiName][funcName].withImplementation(impl, () => {
                result = callback(electron);
            });
            return result?.then ? await result : result;
        }, apiName, funcName, implFn.toString(), callbackFn.toString(), { internal: true });
    };
    return mock;
}
//# sourceMappingURL=mock.js.map