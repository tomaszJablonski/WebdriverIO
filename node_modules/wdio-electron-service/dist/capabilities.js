export function getChromeOptions(options, cap) {
    const existingOptions = cap['goog:chromeOptions'] || {};
    return {
        binary: options.appBinaryPath,
        windowTypes: ['app', 'webview'],
        ...existingOptions,
        args: [...(existingOptions.args || []), ...(options.appArgs || [])],
    };
}
export function getChromedriverOptions(cap) {
    const existingOptions = cap['wdio:chromedriverOptions'] || {};
    return existingOptions;
}
const isElectron = (cap) => cap?.browserName?.toLowerCase() === 'electron';
/**
 * Get capability independent of which type of capabilities is set
 */
export function getElectronCapabilities(caps) {
    /**
     * Standard capabilities, e.g.:
     * ```
     * {
     *   browserName: 'chrome'
     * }
     * ```
     */
    const standardCaps = caps;
    if (typeof standardCaps.browserName === 'string' && isElectron(standardCaps)) {
        return [caps];
    }
    /**
     * W3C specific capabilities, e.g.:
     * ```
     * {
     *   alwaysMatch: {
     *     browserName: 'chrome'
     *   }
     * }
     * ```
     */
    const w3cCaps = caps.alwaysMatch;
    if (w3cCaps && typeof w3cCaps.browserName === 'string' && isElectron(w3cCaps)) {
        return [w3cCaps];
    }
    /**
     * Multiremote capabilities, e.g.:
     * ```
     * {
     *   instanceA: {
     *     capabilities: {
     *        browserName: 'chrome'
     *     }
     *   },
     *   instanceB: {
     *     capabilities: {
     *        browserName: 'chrome'
     *     }
     *   }
     * }
     * ```
     */
    return Object.values(caps)
        .map((options) => options.capabilities?.alwaysMatch ||
        options.capabilities)
        .filter((caps) => isElectron(caps));
}
//# sourceMappingURL=capabilities.js.map